{"version":3,"sources":["luga.data.min.js","luga.data.core.js","luga.data.Dataset.js","luga.data.DetailSet.js","luga.data.HttpDataset.js","luga.data.JsonDataSet.js","luga.data.Region.js"],"names":["luga","namespace","data","version","dataSourceRegistry","CONST","PK_KEY","CUSTOM_ATTRIBUTES","REGION","TEMPLATE","DATA_SOURCE","EVENTS","CURRENT_ROW_CHANGED","DATA_CHANGED","LOADING","XHR_ERROR","SELECTORS","XHR_TIMEOUT","getDataSource","id","undefined","setDataSource","dataSource","DataSet","options","ERROR_MESSAGES","INVALID_ID_PARAMETER","INVALID_PRIMITIVE","INVALID_PRIMITIVE_ARRAY","INVALID_ROW_PARAMETER","INVALID_ROW_ID_PARAMETER","INVALID_ROW_INDEX_PARAMETER","INVALID_FILTER_PARAMETER","filter","jQuery","isFunction","extend","Notifier","this","self","records","recordsHash","filteredRecords","currentRowId","deleteAll","applyFilter","hasFilter","filterRecords","resetCurrentRow","orig","filtered","i","length","newRow","push","selectAll","clearFilter","notifyObservers","getCurrentRow","row","getCurrentRowId","getCurrentRowIndex","getRowIndex","getRecordsCount","getRowById","rowId","getRowByIndex","index","fetchedRow","indexOf","insert","recordsHolder","isArray","isPlainObject","recordID","setCurrentRowId","select","notificationData","oldRowId","oldRow","currentRow","dataSet","setCurrentRow","fetchedRowId","setCurrentRowByIndex","setFilter","DetailSet","INVALID_DS_PARAMETER","addObserver","fetchRow","onDataChangedHandler","onCurrentRowChangedHandler","HttpDataSet","HTTP_DATA_SET_ABSTRACT","XHR_FAILURE","NEED_URL_TO_LOAD","constructor","url","timeout","cache","dataType","xhrRequest","loadUrl","xhrOptions","success","loadRecords","error","xhrError","ajax","cancelRequest","abort","getUrl","loadData","response","textStatus","jqXHR","setUrl","newUrl","errorThrown","message","string","format","status","JsonDataSet","path","getPath","setPath","Region","node","dsId","attr","templateId","template","Handlebars","compile","html","generateHtml","render","document","ready","each","item"],"mappings":"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","file":"luga.data.min.js","sourcesContent":[null,"if(typeof(luga) === \"undefined\"){\r\n\tthrow(\"Unable to find Luga JS Core\");\r\n}\r\n\r\n/**\r\n * @typedef {object} luga.data.dataSourceChanged\r\n *\r\n * @property {luga.data.DataSet|luga.data.DetailSet} dataSource\r\n */\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\tluga.namespace(\"luga.data\");\r\n\r\n\tluga.data.version = \"0.1.6\";\r\n\t/** @type {hash.<luga.data.DataSet>} */\r\n\tluga.data.dataSourceRegistry = {};\r\n\r\n\tluga.data.CONST = {\r\n\t\tPK_KEY: \"rowID\",\r\n\t\tCUSTOM_ATTRIBUTES: {\r\n\t\t\tREGION: \"data-lugads-region\",\r\n\t\t\tTEMPLATE: \"data-lugads-template\",\r\n\t\t\tDATA_SOURCE: \"data-lugads-datasource\"\r\n\t\t},\r\n\t\tEVENTS: {\r\n\t\t\tCURRENT_ROW_CHANGED: \"currentRowChanged\",\r\n\t\t\tDATA_CHANGED: \"dataChanged\",\r\n\t\t\tLOADING: \"loading\",\r\n\t\t\tXHR_ERROR: \"xhrError\"\r\n\t\t},\r\n\t\tSELECTORS: {\r\n\t\t\tREGION: \"*[data-lugads-region]\"\r\n\t\t},\r\n\t\tXHR_TIMEOUT: 10000 // Keep this accessible to everybody\r\n\t};\r\n\r\n\t/**\r\n\t * Returns a dataSource from the registry\r\n\t * Returns null if no source matches the given id\r\n\t * @param {string} id\r\n\t * @returns {luga.data.DataSet|luga.data.DetailSet}\r\n\t */\r\n\tluga.data.getDataSource = function(id){\r\n\t\tif(luga.data.dataSourceRegistry[id] !== undefined){\r\n\t\t\treturn luga.data.dataSourceRegistry[id];\r\n\t\t}\r\n\t\treturn null;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns a dataSource from the registry\r\n\t * Returns null if no source matches the given id\r\n\t * @param {string}                                id\r\n\t * @param {luga.data.DataSet|luga.data.DetailSet} dataSource\r\n\t */\r\n\tluga.data.setDataSource = function(id, dataSource){\r\n\t\tluga.data.dataSourceRegistry[id] = dataSource;\r\n\t};\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.DataSet.row\r\n\t *\r\n\t * @property {string} rowID  Artificial PK\r\n\t */\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.DataSet.currentRowChanged\r\n\t *\r\n\t * @property {string}                oldRowId\r\n\t * @property {luga.data.DataSet.row} oldRow\r\n\t * @property {string}                currentRowId\r\n\t * @property {luga.data.DataSet.row} currentRow\r\n\t * @property {luga.data.DataSet}     dataSet\r\n\t */\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.DataSet.options\r\n\t *\r\n\t * @property {string}              id         Unique identifier. Required\r\n\t * @property {array.<object>|object} records  Records to be loaded, either one single object containing value/name pairs, or an array of name/value pairs\r\n\t * @property {function|null}       filter     A filter functions to be called once for each row in the dataSet. Default to null\r\n\t */\r\n\r\n\t/**\r\n\t * Base DataSet class\r\n\t *\r\n\t * @param {luga.data.DataSet.options} options\r\n\t * @constructor\r\n\t * @extends luga.Notifier\r\n\t * @fires dataChanged\r\n\t * @fires currentRowChanged\r\n\t * @throws\r\n\t */\r\n\tluga.data.DataSet = function(options){\r\n\r\n\t\tvar CONST = {\r\n\t\t\tERROR_MESSAGES: {\r\n\t\t\t\tINVALID_ID_PARAMETER: \"Luga.DataSet: id parameter is required\",\r\n\t\t\t\tINVALID_PRIMITIVE: \"Luga.DataSet: records can be either an array of objects or a single object. Primitives are not accepted\",\r\n\t\t\t\tINVALID_PRIMITIVE_ARRAY: \"Luga.DataSet: records can be either an array of name/value pairs or a single object. Array of primitives are not accepted\",\r\n\t\t\t\tINVALID_ROW_PARAMETER: \"Luga.DataSet: invalid row parameter. No available record matches the given row\",\r\n\t\t\t\tINVALID_ROW_ID_PARAMETER: \"Luga.DataSet: invalid rowId parameter\",\r\n\t\t\t\tINVALID_ROW_INDEX_PARAMETER: \"Luga.DataSet: invalid parameter. Row index is out of range\",\r\n\t\t\t\tINVALID_FILTER_PARAMETER: \"Luga.DataSet: invalid filter. You must use a function as filter\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif(options.id === undefined){\r\n\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ID_PARAMETER);\r\n\t\t}\r\n\t\tif((options.filter !== undefined) && (jQuery.isFunction(options.filter) === false)){\r\n\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_FILTER_PARAMETER);\r\n\t\t}\r\n\t\tluga.extend(luga.Notifier, this);\r\n\r\n\t\t/** @type {luga.data.DataSet} */\r\n\t\tvar self = this;\r\n\r\n\t\tthis.id = options.id;\r\n\t\t/** @type {array.<luga.data.DataSet.row>} */\r\n\t\tthis.records = [];\r\n\t\t/** @type {hash.<luga.data.DataSet.row>} */\r\n\t\tthis.recordsHash = {};\r\n\t\t/** @type {null|array.<luga.data.DataSet.row>} */\r\n\t\tthis.filteredRecords = null;\r\n\t\t/** @type {null|function} */\r\n\t\tthis.filter = null;\r\n\t\tthis.currentRowId = null;\r\n\r\n\t\tluga.data.setDataSource(this.id, this);\r\n\r\n\t\t/* Private methods */\r\n\r\n\t\tvar deleteAll = function(){\r\n\t\t\tself.filteredRecords = null;\r\n\t\t\tself.records = [];\r\n\t\t\tself.recordsHash = {};\r\n\t\t};\r\n\r\n\t\tvar applyFilter = function(){\r\n\t\t\tif(hasFilter() === true){\r\n\t\t\t\tself.filteredRecords = filterRecords(self.records, self.filter);\r\n\t\t\t\tself.resetCurrentRow();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar filterRecords = function(orig, filter){\r\n\t\t\tvar filtered = [];\r\n\t\t\tfor(var i = 0; i < orig.length; i++){\r\n\t\t\t\tvar newRow = filter(this, orig[i], i);\r\n\t\t\t\tif(newRow){\r\n\t\t\t\t\tfiltered.push(newRow);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn filtered;\r\n\t\t};\r\n\r\n\t\tvar hasFilter = function(){\r\n\t\t\treturn (self.filter !== null);\r\n\t\t};\r\n\r\n\t\tvar selectAll = function(){\r\n\t\t\tif(hasFilter() === true){\r\n\t\t\t\treturn self.filteredRecords;\r\n\t\t\t}\r\n\t\t\treturn self.records;\r\n\t\t};\r\n\r\n\t\t/* Public methods */\r\n\r\n\t\t/**\r\n\t\t * Remove the current filter function\r\n\t\t * Triggers a \"dataChanged\" notification\r\n\t\t * @fires dataChanged\r\n\t\t */\r\n\t\tthis.clearFilter = function(){\r\n\t\t\tthis.filter = null;\r\n\t\t\tthis.filteredRecords = null;\r\n\t\t\tthis.notifyObservers(luga.data.CONST.EVENTS.DATA_CHANGED, {dataSource: this});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Delete records matching the given filter\r\n\t\t * If no filter is passed, delete all records\r\n\t\t * @param {function|null} filter   An optional filter function. If specified only records matching the filter will be returned. Default to null\r\n\t\t *                                 The function is going to be called with this signature: myFilter(dataSet, row, rowIndex)\r\n\t\t * @fires currentRowChanged\r\n\t\t * @fires dataChanged\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.delete = function(filter){\r\n\t\t\tif(filter === undefined){\r\n\t\t\t\tdeleteAll();\r\n\t\t\t\tthis.resetCurrentRow();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif(jQuery.isFunction(filter) === false){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_FILTER_PARAMETER);\r\n\t\t\t}\r\n\t\t\tthis.records = filterRecords(selectAll(), filter);\r\n\t\t\tapplyFilter();\r\n\t\t\tthis.resetCurrentRow();\r\n\t\t\tthis.notifyObservers(luga.data.CONST.EVENTS.DATA_CHANGED, {dataSource: this});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the current row object\r\n\t\t * By default, the current row is the first row of the dataSet, but this can be changed by calling setCurrentRow() or setCurrentRowIndex().\r\n\t\t * @return {luga.data.DataSet.row}\r\n\t\t */\r\n\t\tthis.getCurrentRow = function(){\r\n\t\t\tvar row = this.recordsHash[this.getCurrentRowId()];\r\n\t\t\tif(row !== undefined){\r\n\t\t\t\treturn row;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the rowId of the current row\r\n\t\t * Do not confuse the rowId of a row with the index of the row\r\n\t\t * The rowId is a column that contains a unique identifier for the row\r\n\t\t * This identifier does not change if the rows of the data set are sorted\r\n\t\t * @returns {number}\r\n\t\t */\r\n\t\tthis.getCurrentRowId = function(){\r\n\t\t\treturn this.currentRowId;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns a zero-based index at which the current row can be found, or -1 if the dataSet is empty\r\n\t\t * @returns {number}\r\n\t\t */\r\n\t\tthis.getCurrentRowIndex = function(){\r\n\t\t\tvar row = this.getCurrentRow();\r\n\t\t\tif(row !== undefined){\r\n\t\t\t\treturn this.getRowIndex(row);\r\n\t\t\t}\r\n\t\t\treturn -1;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the number of records in the dataSet\r\n\t\t * If the dataSet has a filter, returns the number of filtered records\r\n\t\t * @return {number}\r\n\t\t */\r\n\t\tthis.getRecordsCount = function(){\r\n\t\t\treturn selectAll().length;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the row object associated with the given unique identifier\r\n\t\t * @param {string} rowId  Required\r\n\t\t * @return {luga.data.DataSet.row}\r\n\t\t */\r\n\t\tthis.getRowById = function(rowId){\r\n\t\t\tif(this.recordsHash[rowId] !== undefined){\r\n\t\t\t\treturn this.recordsHash[rowId];\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the row object associated with the given index\r\n\t\t * Throws an exception if the index is out of range\r\n\t\t * @param {number} index  Required\r\n\t\t * @return {luga.data.DataSet.row}\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.getRowByIndex = function(index){\r\n\t\t\tvar fetchedRow;\r\n\t\t\tif(hasFilter() === true){\r\n\t\t\t\tfetchedRow = this.filteredRecords[index];\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tfetchedRow = this.records[index];\r\n\t\t\t}\r\n\t\t\tif(fetchedRow === undefined){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ROW_INDEX_PARAMETER);\r\n\t\t\t}\r\n\t\t\treturn fetchedRow;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the index at which a row can be found in the dataSet, or -1 if no available record matches the given row\r\n\t\t * @param {luga.data.DataSet.row} row\r\n\t\t */\r\n\t\tthis.getRowIndex = function(row){\r\n\t\t\tif(hasFilter() === true){\r\n\t\t\t\treturn this.filteredRecords.indexOf(row);\r\n\t\t\t}\r\n\t\t\treturn this.records.indexOf(row);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Adds rows to a dataSet\r\n\t\t * Be aware that the dataSet use passed data by reference\r\n\t\t * That is, it uses those objects as its row object internally. It does not make a copy\r\n\t\t * @param  {array.<object>|object} records   Records to be loaded, either one single object containing value/name pairs, or an array of name/value pairs. Required\r\n\t\t * @fires dataChanged\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.insert = function(records){\r\n\t\t\t// If we only get one record, we put it inside an array anyway,\r\n\t\t\tvar recordsHolder = [];\r\n\t\t\tif(jQuery.isArray(records) === true){\r\n\t\t\t\trecordsHolder = records;\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\t// Ensure we don't have primitive values\r\n\t\t\t\tif(jQuery.isPlainObject(records) === false){\r\n\t\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_PRIMITIVE);\r\n\t\t\t\t}\r\n\t\t\t\trecordsHolder.push(records);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < recordsHolder.length; i++){\r\n\t\t\t\t// Ensure we don't have primitive values\r\n\t\t\t\tif(jQuery.isPlainObject(recordsHolder[i]) === false){\r\n\t\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_PRIMITIVE_ARRAY);\r\n\t\t\t\t}\r\n\t\t\t\t// Create new PK\r\n\t\t\t\tvar recordID = this.records.length;\r\n\t\t\t\trecordsHolder[i][luga.data.CONST.PK_KEY] = recordID;\r\n\t\t\t\tthis.recordsHash[this.records.length] = recordsHolder[i];\r\n\t\t\t\tthis.records.push(recordsHolder[i]);\r\n\t\t\t}\r\n\t\t\tthis.setCurrentRowId(0);\r\n\t\t\tapplyFilter();\r\n\t\t\tthis.notifyObservers(luga.data.CONST.EVENTS.DATA_CHANGED, {dataSource: this});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Reset the currentRowId\r\n\t\t * @fires currentRowChanged\r\n\t\t */\r\n\t\tthis.resetCurrentRow = function(){\r\n\t\t\t// We have a filter\r\n\t\t\tif(hasFilter() === true){\r\n\t\t\t\tif(this.filteredRecords.length > 0){\r\n\t\t\t\t\t// First among the filtered records\r\n\t\t\t\t\tthis.setCurrentRowId(this.filteredRecords[0][luga.data.CONST.PK_KEY]);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tthis.setCurrentRowId(null);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// No filter\r\n\t\t\tif(this.records.length > 0){\r\n\t\t\t\t// First record\r\n\t\t\t\tthis.setCurrentRowId(this.records[0][luga.data.CONST.PK_KEY]);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tthis.setCurrentRowId(null);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns an array of the internal row objects that store the records in the dataSet\r\n\t\t * Be aware that modifying any property of a returned object results in a modification of the internal records (since records are passed by reference)\r\n\t\t * @param {function|null} filter   An optional filter function. If specified only records matching the filter will be returned. Default to null\r\n\t\t *                                 The function is going to be called with this signature: myFilter(dataSet, row, rowIndex)\r\n\t\t * @return {array.<luga.data.DataSet.row>}\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.select = function(filter){\r\n\t\t\tif(filter === undefined){\r\n\t\t\t\treturn selectAll();\r\n\t\t\t}\r\n\t\t\tif(jQuery.isFunction(filter) === false){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_FILTER_PARAMETER);\r\n\t\t\t}\r\n\t\t\treturn filterRecords(selectAll(), filter);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Sets the current row of the data set to the row matching the given rowId\r\n\t\t * Throws an exception if the given rowId is invalid\r\n\t\t * Triggers a \"currentRowChanged\" notification\r\n\t\t * @param {number|null} rowId  Required\r\n\t\t * @fires currentRowChanged\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.setCurrentRowId = function(rowId){\r\n\t\t\t// No need to do anything\r\n\t\t\tif(this.currentRowId === rowId){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t/**\r\n\t\t\t * @type {luga.data.DataSet.currentRowChanged}\r\n\t\t\t */\r\n\t\t\tvar notificationData = {\r\n\t\t\t\toldRowId: this.currentRowId,\r\n\t\t\t\toldRow: this.getRowById(this.currentRowId),\r\n\t\t\t\tcurrentRowId: rowId,\r\n\t\t\t\tcurrentRow: this.getRowById(rowId),\r\n\t\t\t\tdataSet: this\r\n\t\t\t};\r\n\t\t\t// Set to null\r\n\t\t\tif((rowId === null) && (this.currentRowId !== null)){\r\n\t\t\t\tthis.currentRowId = null;\r\n\t\t\t\tthis.notifyObservers(luga.data.CONST.EVENTS.CURRENT_ROW_CHANGED, notificationData);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// Validate input\r\n\t\t\tif(this.getRowById(rowId) === null){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ROW_ID_PARAMETER);\r\n\t\t\t}\r\n\t\t\tthis.currentRowId = rowId;\r\n\t\t\tthis.notifyObservers(luga.data.CONST.EVENTS.CURRENT_ROW_CHANGED, notificationData);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Set the passed row as currentRow\r\n\t\t * Throws an exception if no available record matches the given row\r\n\t\t * @param {luga.data.DataSet.row} row\r\n\t\t * @fires currentRowChanged\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.setCurrentRow = function(row){\r\n\t\t\tvar fetchedRowId = this.getRowIndex(row);\r\n\t\t\tif(fetchedRowId === -1){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ROW_PARAMETER);\r\n\t\t\t}\r\n\t\t\tthis.setCurrentRowId(fetchedRowId);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Sets the current row of the dataSet to the one matching the given index\r\n\t\t * Throws an exception if the index is out of range\r\n\t\t * @param {number} index\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.setCurrentRowByIndex = function(index){\r\n\t\t\tthis.setCurrentRow(this.getRowByIndex(index));\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Replace current filter with a new filter functions and apply the new filter\r\n\t\t * Triggers a \"dataChanged\" notification\r\n\t\t * @param {function} filter   A filter functions to be called once for each row in the data set. Required\r\n\t\t *                            The function is going to be called with this signature: myFilter(dataSet, row, rowIndex)\r\n\t\t * @fires currentRowChanged\r\n\t\t * @fires dataChanged\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.setFilter = function(filter){\r\n\t\t\tif(jQuery.isFunction(filter) === false){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_FILTER_PARAMETER);\r\n\t\t\t}\r\n\t\t\tthis.filter = filter;\r\n\t\t\tapplyFilter();\r\n\t\t\tthis.notifyObservers(luga.data.CONST.EVENTS.DATA_CHANGED, {dataSource: this});\r\n\t\t};\r\n\r\n\t\t/* Constructor */\r\n\r\n\t\tif(options.filter !== undefined){\r\n\t\t\tthis.setFilter(options.filter);\r\n\t\t}\r\n\t\tif(options.records !== undefined){\r\n\t\t\tthis.insert(options.records);\r\n\t\t}\r\n\r\n\t};\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.DetailSet.options\r\n\t *\r\n\t * @property {string}              id     Unique identifier. Required\r\n\t * @property {luga.data.DataSet} dataSet  Master dataSet\r\n\t */\r\n\r\n\t/**\r\n\t * DetailSet class\r\n\t * Register itself as observer of the passed dataSet and act as the details in a master/details scenario\r\n\t *\r\n\t * @param {luga.data.DetailSet.options} options\r\n\t * @constructor\r\n\t * @extends luga.Notifier\r\n\t * @fires dataChanged\r\n\t * @listens dataChanged\r\n\t * @listens currentRowChanged\r\n\t */\r\n\tluga.data.DetailSet = function(options){\r\n\r\n\t\tvar CONST = {\r\n\t\t\tERROR_MESSAGES: {\r\n\t\t\t\tINVALID_ID_PARAMETER: \"Luga.DetailSet: id parameter is required\",\r\n\t\t\t\tINVALID_DS_PARAMETER: \"Luga.DetailSet: dataSet parameter is required\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif(options.id === undefined){\r\n\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ID_PARAMETER);\r\n\t\t}\r\n\t\tif(options.dataSet === undefined){\r\n\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_DS_PARAMETER);\r\n\t\t}\r\n\r\n\t\tluga.extend(luga.Notifier, this);\r\n\r\n\t\t/** @type {luga.data.DetailSet} */\r\n\t\tvar self = this;\r\n\r\n\t\tthis.id = options.id;\r\n\t\tthis.dataSet = options.dataSet;\r\n\t\tthis.dataSet.addObserver(this);\r\n\r\n\t\t/** @type {luga.data.DataSet.row} */\r\n\t\tthis.row = null;\r\n\r\n\t\tluga.data.setDataSource(this.id, this);\r\n\r\n\t\tthis.fetchRow = function(){\r\n\t\t\tself.row = self.dataSet.getCurrentRow();\r\n\t\t};\r\n\r\n\t\t/* Events Handlers */\r\n\r\n\t\t/**\r\n\t\t * @param {luga.data.dataSourceChanged} data\r\n\t\t */\r\n\t\tthis.onDataChangedHandler = function(data){\r\n\t\t\tself.fetchRow();\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * @param {luga.data.DataSet.currentRowChanged} data\r\n\t\t */\r\n\t\tthis.onCurrentRowChangedHandler = function(data){\r\n\t\t\tself.fetchRow();\r\n\t\t};\r\n\r\n\t\t/* Constructor */\r\n\r\n\t\tthis.fetchRow();\r\n\r\n\t};\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.DataSet.loading\r\n\t *\r\n\t * @property {luga.data.DataSet} dataSet\r\n\t */\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.HttpDataSet.xhrError\r\n\t *\r\n\t * @property {string} message\r\n\t * @property {object} jqXHR        jQuery wrapper around XMLHttpRequest\r\n\t * @property {string} textStatus\r\n\t * @property {string} errorThrown\r\n\t */\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.HttpDataSet.options\r\n\t *\r\n\t * @extends luga.data.DataSet.options\r\n\t * @property {string|null}   url       URL to be fetched. Default to null\r\n\t * @property {number}        timeout   Timeout (in milliseconds) for the HTTP request. Default to 10 seconds\r\n\t * @property {boolean}       cache     If set to false, it will force requested pages not to be cached by the browser.\r\n\t *                                     It works by appending \"_={timestamp}\" to the querystring. Default to true\r\n\t */\r\n\r\n\t/**\r\n\t * Base HttpDataSet class\r\n\t * @param luga.data.HttpDataSet.options\r\n\t * @constructor\r\n\t * @extends luga.data.DataSet\r\n\t * @abstract\r\n\t * @fires loading\r\n\t * @fires xhrError\r\n\t * @throws\r\n\t */\r\n\tluga.data.HttpDataSet = function(options){\r\n\t\tluga.extend(luga.data.DataSet, this, [options]);\r\n\t\t/** @type {luga.data.HttpDataSet} */\r\n\t\tvar self = this;\r\n\r\n\t\tvar CONST = {\r\n\t\t\tERROR_MESSAGES: {\r\n\t\t\t\tHTTP_DATA_SET_ABSTRACT: \"luga.data.HttpDataSet is an abstract class\",\r\n\t\t\t\tXHR_FAILURE: \"Failed to retrieve: {0}. HTTP status: {1}. Error: {2}\",\r\n\t\t\t\tNEED_URL_TO_LOAD: \"Unable to call loadData(). DataSet is missing a URL\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif(this.constructor === luga.data.HttpDataSet){\r\n\t\t\tthrow(CONST.ERROR_MESSAGES.HTTP_DATA_SET_ABSTRACT);\r\n\t\t}\r\n\r\n\t\tthis.url = null;\r\n\t\tif(options.url !== undefined){\r\n\t\t\tthis.url = options.url;\r\n\t\t}\r\n\r\n\t\tthis.timeout = luga.data.CONST.XHR_TIMEOUT;\r\n\t\tif(options.timeout !== undefined){\r\n\t\t\tthis.timeout = options.timeout;\r\n\t\t}\r\n\r\n\t\tthis.cache = true;\r\n\t\tif(options.cache !== undefined){\r\n\t\t\tthis.cache = options.cache;\r\n\t\t}\r\n\t\t// Concrete implementations can override this\r\n\t\tthis.dataType = null;\r\n\t\tthis.xhrRequest = null;\r\n\r\n\t\t/* Private methods */\r\n\r\n\t\tvar loadUrl = function(){\r\n\t\t\tvar xhrOptions = {\r\n\t\t\t\turl: self.url,\r\n\t\t\t\tsuccess: self.loadRecords,\r\n\t\t\t\ttimeout: self.timeout,\r\n\t\t\t\tcache: self.cache,\r\n\t\t\t\terror: self.xhrError\r\n\t\t\t};\r\n\t\t\tif(self.dataType !== null){\r\n\t\t\t\txhrOptions.dataType = self.dataType;\r\n\t\t\t}\r\n\t\t\tself.xhrRequest = jQuery.ajax(xhrOptions);\r\n\t\t};\r\n\r\n\t\t/* Public methods */\r\n\r\n\t\t/**\r\n\t\t * Abort any pending XHR request\r\n\t\t */\r\n\t\tthis.cancelRequest = function(){\r\n\t\t\tif(this.xhrRequest !== null){\r\n\t\t\t\tthis.xhrRequest.abort();\r\n\t\t\t\tthis.xhrRequest = null;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the URL that will be used to fetch the data. Returns null if URL is not set\r\n\t\t * @returns {string|null}\r\n\t\t */\r\n\t\tthis.getUrl = function(){\r\n\t\t\treturn this.url;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Fires off XHR request to fetch and load the data, notify observers (\"loading\" first, \"dataChanged\" after records are loaded).\r\n\t\t * Does nothing if URL is not set\r\n\t\t * @fires loading\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.loadData = function(){\r\n\t\t\tif(this.url === null){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.NEED_URL_TO_LOAD);\r\n\t\t\t}\r\n\t\t\tthis.notifyObservers(luga.data.CONST.EVENTS.LOADING, {dataSet: this});\r\n\t\t\tthis.cancelRequest();\r\n\t\t\tthis.delete();\r\n\t\t\tloadUrl();\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Abstract method, child classes must implement it to extract records from XHR response\r\n\t\t * @param {*}        response     Data returned from the server\r\n\t\t * @param {string}   textStatus   HTTP status\r\n\t\t * @param {object}   jqXHR        jQuery wrapper around XMLHttpRequest\r\n\t\t * @abstract\r\n\t\t */\r\n\t\tthis.loadRecords = function(response, textStatus, jqXHR){\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Set the URL that will be used to fetch the data.\r\n\t\t * This method does not load the data into the data set, it merely sets the internal URL.\r\n\t\t * The developer must call loadData() to actually trigger the data loading\r\n\t\t * @param {string} newUrl\r\n\t\t */\r\n\t\tthis.setUrl = function(newUrl){\r\n\t\t\tthis.url = newUrl;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Is called whenever an XHR request fails, notify observers (\"xhrError\")\r\n\t\t * @param {object}   jqXHR        jQuery wrapper around XMLHttpRequest\r\n\t\t * @param {string}   textStatus   HTTP status\r\n\t\t * @param {string}   errorThrown  Error message from jQuery\r\n\t\t * @fires xhrError\r\n\t\t */\r\n\t\tthis.xhrError = function(jqXHR, textStatus, errorThrown){\r\n\t\t\tself.notifyObservers(luga.data.CONST.EVENTS.XHR_ERROR, {\r\n\t\t\t\tdataSet: self,\r\n\t\t\t\tmessage: luga.string.format(CONST.ERROR_MESSAGES.XHR_FAILURE, [self.url, jqXHR.status, errorThrown]),\r\n\t\t\t\tjqXHR: jqXHR,\r\n\t\t\t\ttextStatus: textStatus,\r\n\t\t\t\terrorThrown: errorThrown\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.JsonDataSet.options\r\n\t *\r\n\t * @extends luga.data.HttpDataSet.options\r\n\t * @property {string|null}   path      Specifies the path to the data within the JSON structure. Default to null\r\n\t */\r\n\r\n\t/**\r\n\t * JSON dataSet class\r\n\t * @param {luga.data.JsonDataSet.options} options\r\n\t * @constructor\r\n\t * @extends luga.data.HttpDataSet\r\n\t */\r\n\tluga.data.JsonDataSet = function(options){\r\n\t\tluga.extend(luga.data.HttpDataSet, this, [options]);\r\n\t\t/** @type {luga.data.JsonDataSet} */\r\n\t\tvar self = this;\r\n\t\t/** @override */\r\n\t\tthis.dataType = \"json\";\r\n\r\n\t\tthis.path = null;\r\n\t\tif(options.path !== undefined){\r\n\t\t\tthis.path = options.path;\r\n\t\t}\r\n\r\n\t\t/* Public methods */\r\n\r\n\t\t/**\r\n\t\t * Returns the path to be used to extract data out of the JSON data structure\r\n\t\t * @returns {string|null}\r\n\t\t */\r\n\t\tthis.getPath = function(){\r\n\t\t\treturn this.path;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Receives HTTP response, extracts and loads records out of it\r\n\t\t * @param {*}        response     Data returned from the server\r\n\t\t * @param {string}   textStatus   HTTP status\r\n\t\t * @param {object}   jqXHR        jQuery wrapper around XMLHttpRequest\r\n\t\t * @override\r\n\t\t */\r\n\t\tthis.loadRecords = function(response, textStatus, jqXHR){\r\n\t\t\tif(self.path === null){\r\n\t\t\t\tself.insert(response);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tif(response[self.path] !== undefined){\r\n\t\t\t\t\tself.insert(response[self.path]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Set the path to be used to extract data out of the JSON data structure\r\n\t\t * @param {string} path\r\n\t\t */\r\n\t\tthis.setPath = function(path){\r\n\t\t\tthis.path = path;\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.Region.options\r\n\t *\r\n\t * @property {jquery} node  Either a jQuery object wrapping the node or the naked DOM object that will contain the region. Required\r\n\t *\r\n\t */\r\n\r\n\t/**\r\n\t * Data Region class\r\n\t * @param {luga.data.Region.options} options\r\n\t * @listens dataChanged\r\n\t * @throws\r\n\t */\r\n\tluga.data.Region = function(options){\r\n\t\tif(typeof(Handlebars) === \"undefined\"){\r\n\t\t\tthrow(\"Unable to find Handlebars\");\r\n\t\t}\r\n\r\n\t\tvar self = this;\r\n\r\n\t\tthis.node = jQuery(options.node);\r\n\t\tthis.dsId = this.node.attr(luga.data.CONST.CUSTOM_ATTRIBUTES.DATA_SOURCE);\r\n\t\t/** @type {luga.data.DataSet|luga.data.DetailSet} */\r\n\t\tthis.dataSource = luga.data.getDataSource(this.dsId);\r\n\t\tthis.dataSource.addObserver(this);\r\n\r\n\t\tthis.templateId = this.node.attr(luga.data.CONST.CUSTOM_ATTRIBUTES.TEMPLATE);\r\n\t\tif(this.templateId !== undefined){\r\n\t\t\tthis.template = Handlebars.compile(jQuery(\"#\" + this.templateId).html());\r\n\t\t}\r\n\t\telse{\r\n\t\t\tthis.template = Handlebars.compile(this.node.html());\r\n\t\t}\r\n\r\n\t\tthis.generateHtml = function(){\r\n\t\t\treturn this.template(this.dataSource);\r\n\t\t};\r\n\r\n\t\tthis.render = function(){\r\n\t\t\tthis.node.html(this.generateHtml());\r\n\t\t};\r\n\r\n\t\t/* Events Handlers */\r\n\r\n\t\t/**\r\n\t\t * @param {luga.data.dataSourceChanged} data\r\n\t\t */\r\n\t\tthis.onDataChangedHandler = function(data){\r\n\t\t\tself.render();\r\n\t\t};\r\n\t};\r\n\r\n\tjQuery(document).ready(function(){\r\n\t\tjQuery(luga.data.CONST.SELECTORS.REGION).each(function(index, item){\r\n\t\t\tnew luga.data.Region({\r\n\t\t\t\tnode: jQuery(item)\r\n\t\t\t});\r\n\t\t});\r\n\t});\r\n\r\n}());"],"sourceRoot":"."}