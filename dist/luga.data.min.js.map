{"version":3,"sources":["luga.data.min.js","luga.data.core.js","luga.data.Dataset.js","luga.data.DetailSet.js","luga.data.HttpDataset.js","luga.data.JsonDataSet.js","luga.data.Region.js"],"names":["luga","namespace","data","version","dataSourceRegistry","CONST","PK_KEY","CUSTOM_ATTRIBUTES","REGION","TEMPLATE","DATA_SOURCE","EVENTS","CURRENT_ROW_CHANGED","DATA_CHANGED","LOADING","XHR_ERROR","SELECTORS","XHR_TIMEOUT","getDataSource","id","undefined","setDataSource","dataSource","DataSet","options","ERROR_MESSAGES","INVALID_ID_PARAMETER","INVALID_PRIMITIVE","INVALID_PRIMITIVE_ARRAY","INVALID_ROW_PARAMETER","INVALID_ROW_ID_PARAMETER","INVALID_ROW_INDEX_PARAMETER","INVALID_FILTER_PARAMETER","filter","jQuery","isFunction","extend","Notifier","this","self","records","recordsHash","filteredRecords","currentRowId","deleteAll","applyFilter","hasFilter","filterRecords","resetCurrentRow","orig","filtered","i","length","newRow","push","selectAll","clearFilter","notifyObservers","getContext","select","getCurrentRow","row","getCurrentRowId","getCurrentRowIndex","getRowIndex","getRecordsCount","getRowById","rowId","getRowByIndex","index","fetchedRow","indexOf","insert","recordsHolder","isArray","isPlainObject","recordID","setCurrentRowId","notificationData","oldRowId","oldRow","currentRow","dataSet","setCurrentRow","fetchedRowId","setCurrentRowIndex","setFilter","DetailSet","INVALID_DS_PARAMETER","addObserver","fetchRow","onDataChangedHandler","onCurrentRowChangedHandler","HttpDataSet","HTTP_DATA_SET_ABSTRACT","XHR_FAILURE","NEED_URL_TO_LOAD","constructor","url","timeout","cache","dataType","xhrRequest","loadUrl","xhrOptions","success","loadRecords","error","xhrError","ajax","cancelRequest","abort","getUrl","loadData","response","textStatus","jqXHR","setUrl","newUrl","errorThrown","message","string","format","status","JsonDataSet","path","getPath","setPath","Region","node","dsId","attr","templateId","template","Handlebars","compile","html","generateHtml","render","document","ready","each","item"],"mappings":"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","file":"luga.data.min.js","sourcesContent":[null,"if(typeof(luga) === \"undefined\"){\r\n\tthrow(\"Unable to find Luga JS Core\");\r\n}\r\n\r\n/**\r\n * @typedef {object} luga.data.dataSourceChanged\r\n *\r\n * @property {luga.data.DataSet|luga.data.DetailSet} dataSource\r\n */\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\tluga.namespace(\"luga.data\");\r\n\r\n\tluga.data.version = \"0.1.8\";\r\n\t/** @type {hash.<luga.data.DataSet>} */\r\n\tluga.data.dataSourceRegistry = {};\r\n\r\n\tluga.data.CONST = {\r\n\t\tPK_KEY: \"rowId\",\r\n\t\tCUSTOM_ATTRIBUTES: {\r\n\t\t\tREGION: \"data-lugads-region\",\r\n\t\t\tTEMPLATE: \"data-lugads-template\",\r\n\t\t\tDATA_SOURCE: \"data-lugads-datasource\"\r\n\t\t},\r\n\t\tEVENTS: {\r\n\t\t\tCURRENT_ROW_CHANGED: \"currentRowChanged\",\r\n\t\t\tDATA_CHANGED: \"dataChanged\",\r\n\t\t\tLOADING: \"loading\",\r\n\t\t\tXHR_ERROR: \"xhrError\"\r\n\t\t},\r\n\t\tSELECTORS: {\r\n\t\t\tREGION: \"*[data-lugads-region]\"\r\n\t\t},\r\n\t\tXHR_TIMEOUT: 10000 // Keep this accessible to everybody\r\n\t};\r\n\r\n\t/**\r\n\t * Returns a dataSource from the registry\r\n\t * Returns null if no source matches the given id\r\n\t * @param {string} id\r\n\t * @returns {luga.data.DataSet|luga.data.DetailSet}\r\n\t */\r\n\tluga.data.getDataSource = function(id){\r\n\t\tif(luga.data.dataSourceRegistry[id] !== undefined){\r\n\t\t\treturn luga.data.dataSourceRegistry[id];\r\n\t\t}\r\n\t\treturn null;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns a dataSource from the registry\r\n\t * Returns null if no source matches the given id\r\n\t * @param {string}                                id\r\n\t * @param {luga.data.DataSet|luga.data.DetailSet} dataSource\r\n\t */\r\n\tluga.data.setDataSource = function(id, dataSource){\r\n\t\tluga.data.dataSourceRegistry[id] = dataSource;\r\n\t};\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.DataSet.row\r\n\t *\r\n\t * @property {string} rowID  Artificial PK\r\n\t */\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.DataSet.currentRowChanged\r\n\t *\r\n\t * @property {string}                oldRowId\r\n\t * @property {luga.data.DataSet.row} oldRow\r\n\t * @property {string}                currentRowId\r\n\t * @property {luga.data.DataSet.row} currentRow\r\n\t * @property {luga.data.DataSet}     dataSet\r\n\t */\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.DataSet.options\r\n\t *\r\n\t * @property {string}              id         Unique identifier. Required\r\n\t * @property {array.<object>|object} records  Records to be loaded, either one single object containing value/name pairs, or an array of name/value pairs\r\n\t * @property {function|null}       filter     A filter functions to be called once for each row in the dataSet. Default to null\r\n\t */\r\n\r\n\t/**\r\n\t * Base DataSet class\r\n\t *\r\n\t * @param {luga.data.DataSet.options} options\r\n\t * @constructor\r\n\t * @extends luga.Notifier\r\n\t * @fires dataChanged\r\n\t * @fires currentRowChanged\r\n\t * @throws\r\n\t */\r\n\tluga.data.DataSet = function(options){\r\n\r\n\t\tvar CONST = {\r\n\t\t\tERROR_MESSAGES: {\r\n\t\t\t\tINVALID_ID_PARAMETER: \"Luga.DataSet: id parameter is required\",\r\n\t\t\t\tINVALID_PRIMITIVE: \"Luga.DataSet: records can be either an array of objects or a single object. Primitives are not accepted\",\r\n\t\t\t\tINVALID_PRIMITIVE_ARRAY: \"Luga.DataSet: records can be either an array of name/value pairs or a single object. Array of primitives are not accepted\",\r\n\t\t\t\tINVALID_ROW_PARAMETER: \"Luga.DataSet: invalid row parameter. No available record matches the given row\",\r\n\t\t\t\tINVALID_ROW_ID_PARAMETER: \"Luga.DataSet: invalid rowId parameter\",\r\n\t\t\t\tINVALID_ROW_INDEX_PARAMETER: \"Luga.DataSet: invalid parameter. Row index is out of range\",\r\n\t\t\t\tINVALID_FILTER_PARAMETER: \"Luga.DataSet: invalid filter. You must use a function as filter\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif(options.id === undefined){\r\n\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ID_PARAMETER);\r\n\t\t}\r\n\t\tif((options.filter !== undefined) && (jQuery.isFunction(options.filter) === false)){\r\n\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_FILTER_PARAMETER);\r\n\t\t}\r\n\t\tluga.extend(luga.Notifier, this);\r\n\r\n\t\t/** @type {luga.data.DataSet} */\r\n\t\tvar self = this;\r\n\r\n\t\tthis.id = options.id;\r\n\t\t/** @type {array.<luga.data.DataSet.row>} */\r\n\t\tthis.records = [];\r\n\t\t/** @type {hash.<luga.data.DataSet.row>} */\r\n\t\tthis.recordsHash = {};\r\n\t\t/** @type {null|array.<luga.data.DataSet.row>} */\r\n\t\tthis.filteredRecords = null;\r\n\t\t/** @type {null|function} */\r\n\t\tthis.filter = null;\r\n\t\tthis.currentRowId = null;\r\n\r\n\t\tluga.data.setDataSource(this.id, this);\r\n\r\n\t\t/* Private methods */\r\n\r\n\t\tvar deleteAll = function(){\r\n\t\t\tself.filteredRecords = null;\r\n\t\t\tself.records = [];\r\n\t\t\tself.recordsHash = {};\r\n\t\t};\r\n\r\n\t\tvar applyFilter = function(){\r\n\t\t\tif(hasFilter() === true){\r\n\t\t\t\tself.filteredRecords = filterRecords(self.records, self.filter);\r\n\t\t\t\tself.resetCurrentRow();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar filterRecords = function(orig, filter){\r\n\t\t\tvar filtered = [];\r\n\t\t\tfor(var i = 0; i < orig.length; i++){\r\n\t\t\t\tvar newRow = filter(this, orig[i], i);\r\n\t\t\t\tif(newRow){\r\n\t\t\t\t\tfiltered.push(newRow);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn filtered;\r\n\t\t};\r\n\r\n\t\tvar hasFilter = function(){\r\n\t\t\treturn (self.filter !== null);\r\n\t\t};\r\n\r\n\t\tvar selectAll = function(){\r\n\t\t\tif(hasFilter() === true){\r\n\t\t\t\treturn self.filteredRecords;\r\n\t\t\t}\r\n\t\t\treturn self.records;\r\n\t\t};\r\n\r\n\t\t/* Public methods */\r\n\r\n\t\t/**\r\n\t\t * Remove the current filter function\r\n\t\t * Triggers a \"dataChanged\" notification\r\n\t\t * @fires dataChanged\r\n\t\t */\r\n\t\tthis.clearFilter = function(){\r\n\t\t\tthis.filter = null;\r\n\t\t\tthis.filteredRecords = null;\r\n\t\t\tthis.notifyObservers(luga.data.CONST.EVENTS.DATA_CHANGED, {dataSource: this});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Delete records matching the given filter\r\n\t\t * If no filter is passed, delete all records\r\n\t\t * @param {function|null} filter   An optional filter function. If specified only records matching the filter will be returned. Default to null\r\n\t\t *                                 The function is going to be called with this signature: myFilter(dataSet, row, rowIndex)\r\n\t\t * @fires currentRowChanged\r\n\t\t * @fires dataChanged\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.delete = function(filter){\r\n\t\t\tif(filter === undefined){\r\n\t\t\t\tdeleteAll();\r\n\t\t\t\tthis.resetCurrentRow();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif(jQuery.isFunction(filter) === false){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_FILTER_PARAMETER);\r\n\t\t\t}\r\n\t\t\tthis.records = filterRecords(selectAll(), filter);\r\n\t\t\tapplyFilter();\r\n\t\t\tthis.resetCurrentRow();\r\n\t\t\tthis.notifyObservers(luga.data.CONST.EVENTS.DATA_CHANGED, {dataSource: this});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * @returns {{records: array.<luga.data.DataSet.row>}}\r\n\t\t */\r\n\t\tthis.getContext = function(){\r\n\t\t\treturn {records: self.select()};\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the current row object\r\n\t\t * By default, the current row is the first row of the dataSet, but this can be changed by calling setCurrentRow() or setCurrentRowIndex().\r\n\t\t * @return {luga.data.DataSet.row}\r\n\t\t */\r\n\t\tthis.getCurrentRow = function(){\r\n\t\t\tvar row = this.recordsHash[this.getCurrentRowId()];\r\n\t\t\tif(row !== undefined){\r\n\t\t\t\treturn row;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the rowId of the current row\r\n\t\t * Do not confuse the rowId of a row with the index of the row\r\n\t\t * The rowId is a column that contains a unique identifier for the row\r\n\t\t * This identifier does not change if the rows of the data set are sorted\r\n\t\t * @returns {number}\r\n\t\t */\r\n\t\tthis.getCurrentRowId = function(){\r\n\t\t\treturn this.currentRowId;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns a zero-based index at which the current row can be found, or -1 if the dataSet is empty\r\n\t\t * @returns {number}\r\n\t\t */\r\n\t\tthis.getCurrentRowIndex = function(){\r\n\t\t\tvar row = this.getCurrentRow();\r\n\t\t\tif(row !== undefined){\r\n\t\t\t\treturn this.getRowIndex(row);\r\n\t\t\t}\r\n\t\t\treturn -1;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the number of records in the dataSet\r\n\t\t * If the dataSet has a filter, returns the number of filtered records\r\n\t\t * @return {number}\r\n\t\t */\r\n\t\tthis.getRecordsCount = function(){\r\n\t\t\treturn selectAll().length;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the row object associated with the given unique identifier\r\n\t\t * @param {string} rowId  Required\r\n\t\t * @return {luga.data.DataSet.row}\r\n\t\t */\r\n\t\tthis.getRowById = function(rowId){\r\n\t\t\tif(this.recordsHash[rowId] !== undefined){\r\n\t\t\t\treturn this.recordsHash[rowId];\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the row object associated with the given index\r\n\t\t * Throws an exception if the index is out of range\r\n\t\t * @param {number} index  Required\r\n\t\t * @return {luga.data.DataSet.row}\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.getRowByIndex = function(index){\r\n\t\t\tvar fetchedRow;\r\n\t\t\tif(hasFilter() === true){\r\n\t\t\t\tfetchedRow = this.filteredRecords[index];\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tfetchedRow = this.records[index];\r\n\t\t\t}\r\n\t\t\tif(fetchedRow === undefined){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ROW_INDEX_PARAMETER);\r\n\t\t\t}\r\n\t\t\treturn fetchedRow;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the index at which a row can be found in the dataSet, or -1 if no available record matches the given row\r\n\t\t * @param {luga.data.DataSet.row} row\r\n\t\t */\r\n\t\tthis.getRowIndex = function(row){\r\n\t\t\tif(hasFilter() === true){\r\n\t\t\t\treturn this.filteredRecords.indexOf(row);\r\n\t\t\t}\r\n\t\t\treturn this.records.indexOf(row);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Adds rows to a dataSet\r\n\t\t * Be aware that the dataSet use passed data by reference\r\n\t\t * That is, it uses those objects as its row object internally. It does not make a copy\r\n\t\t * @param  {array.<object>|object} records   Records to be loaded, either one single object containing value/name pairs, or an array of name/value pairs. Required\r\n\t\t * @fires dataChanged\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.insert = function(records){\r\n\t\t\t// If we only get one record, we put it inside an array anyway,\r\n\t\t\tvar recordsHolder = [];\r\n\t\t\tif(jQuery.isArray(records) === true){\r\n\t\t\t\trecordsHolder = records;\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\t// Ensure we don't have primitive values\r\n\t\t\t\tif(jQuery.isPlainObject(records) === false){\r\n\t\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_PRIMITIVE);\r\n\t\t\t\t}\r\n\t\t\t\trecordsHolder.push(records);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < recordsHolder.length; i++){\r\n\t\t\t\t// Ensure we don't have primitive values\r\n\t\t\t\tif(jQuery.isPlainObject(recordsHolder[i]) === false){\r\n\t\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_PRIMITIVE_ARRAY);\r\n\t\t\t\t}\r\n\t\t\t\t// Create new PK\r\n\t\t\t\tvar recordID = this.records.length;\r\n\t\t\t\trecordsHolder[i][luga.data.CONST.PK_KEY] = recordID;\r\n\t\t\t\tthis.recordsHash[this.records.length] = recordsHolder[i];\r\n\t\t\t\tthis.records.push(recordsHolder[i]);\r\n\t\t\t}\r\n\t\t\tthis.setCurrentRowId(0);\r\n\t\t\tapplyFilter();\r\n\t\t\tthis.notifyObservers(luga.data.CONST.EVENTS.DATA_CHANGED, {dataSource: this});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Reset the currentRowId\r\n\t\t * @fires currentRowChanged\r\n\t\t */\r\n\t\tthis.resetCurrentRow = function(){\r\n\t\t\t// We have a filter\r\n\t\t\tif(hasFilter() === true){\r\n\t\t\t\tif(this.filteredRecords.length > 0){\r\n\t\t\t\t\t// First among the filtered records\r\n\t\t\t\t\tthis.setCurrentRowId(this.filteredRecords[0][luga.data.CONST.PK_KEY]);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tthis.setCurrentRowId(null);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// No filter\r\n\t\t\tif(this.records.length > 0){\r\n\t\t\t\t// First record\r\n\t\t\t\tthis.setCurrentRowId(this.records[0][luga.data.CONST.PK_KEY]);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tthis.setCurrentRowId(null);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns an array of the internal row objects that store the records in the dataSet\r\n\t\t * Be aware that modifying any property of a returned object results in a modification of the internal records (since records are passed by reference)\r\n\t\t * @param {function|null} filter   An optional filter function. If specified only records matching the filter will be returned. Default to null\r\n\t\t *                                 The function is going to be called with this signature: myFilter(dataSet, row, rowIndex)\r\n\t\t * @return {array.<luga.data.DataSet.row>}\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.select = function(filter){\r\n\t\t\tif(filter === undefined){\r\n\t\t\t\treturn selectAll();\r\n\t\t\t}\r\n\t\t\tif(jQuery.isFunction(filter) === false){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_FILTER_PARAMETER);\r\n\t\t\t}\r\n\t\t\treturn filterRecords(selectAll(), filter);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Sets the current row of the data set to the row matching the given rowId\r\n\t\t * Throws an exception if the given rowId is invalid\r\n\t\t * Triggers a \"currentRowChanged\" notification\r\n\t\t * @param {number|null} rowId  Required\r\n\t\t * @fires currentRowChanged\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.setCurrentRowId = function(rowId){\r\n\t\t\t// No need to do anything\r\n\t\t\tif(this.currentRowId === rowId){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t/**\r\n\t\t\t * @type {luga.data.DataSet.currentRowChanged}\r\n\t\t\t */\r\n\t\t\tvar notificationData = {\r\n\t\t\t\toldRowId: this.getCurrentRowId(),\r\n\t\t\t\toldRow: this.getRowById(this.currentRowId),\r\n\t\t\t\tcurrentRowId: rowId,\r\n\t\t\t\tcurrentRow: this.getRowById(rowId),\r\n\t\t\t\tdataSet: this\r\n\t\t\t};\r\n\t\t\t// Set to null\r\n\t\t\tif((rowId === null) && (this.currentRowId !== null)){\r\n\t\t\t\tthis.currentRowId = null;\r\n\t\t\t\tthis.notifyObservers(luga.data.CONST.EVENTS.CURRENT_ROW_CHANGED, notificationData);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// Validate input\r\n\t\t\tif(this.getRowById(rowId) === null){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ROW_ID_PARAMETER);\r\n\t\t\t}\r\n\t\t\tthis.currentRowId = rowId;\r\n\t\t\tthis.notifyObservers(luga.data.CONST.EVENTS.CURRENT_ROW_CHANGED, notificationData);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Set the passed row as currentRow\r\n\t\t * Throws an exception if no available record matches the given row\r\n\t\t * @param {luga.data.DataSet.row} row\r\n\t\t * @fires currentRowChanged\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.setCurrentRow = function(row){\r\n\t\t\tvar fetchedRowId = this.getRowIndex(row);\r\n\t\t\tif(fetchedRowId === -1){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ROW_PARAMETER);\r\n\t\t\t}\r\n\t\t\tthis.setCurrentRowId(fetchedRowId);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Sets the current row of the dataSet to the one matching the given index\r\n\t\t * Throws an exception if the index is out of range\r\n\t\t * @param {number} index\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.setCurrentRowIndex = function(index){\r\n\t\t\tthis.setCurrentRow(this.getRowByIndex(index));\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Replace current filter with a new filter functions and apply the new filter\r\n\t\t * Triggers a \"dataChanged\" notification\r\n\t\t * @param {function} filter   A filter functions to be called once for each row in the data set. Required\r\n\t\t *                            The function is going to be called with this signature: myFilter(dataSet, row, rowIndex)\r\n\t\t * @fires currentRowChanged\r\n\t\t * @fires dataChanged\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.setFilter = function(filter){\r\n\t\t\tif(jQuery.isFunction(filter) === false){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_FILTER_PARAMETER);\r\n\t\t\t}\r\n\t\t\tthis.filter = filter;\r\n\t\t\tapplyFilter();\r\n\t\t\tthis.notifyObservers(luga.data.CONST.EVENTS.DATA_CHANGED, {dataSource: this});\r\n\t\t};\r\n\r\n\t\t/* Constructor */\r\n\r\n\t\tif(options.filter !== undefined){\r\n\t\t\tthis.setFilter(options.filter);\r\n\t\t}\r\n\t\tif(options.records !== undefined){\r\n\t\t\tthis.insert(options.records);\r\n\t\t}\r\n\r\n\t};\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.DetailSet.options\r\n\t *\r\n\t * @property {string}            id       Unique identifier. Required\r\n\t * @property {luga.data.DataSet} dataSet  Master dataSet\r\n\t */\r\n\r\n\t/**\r\n\t * DetailSet class\r\n\t * Register itself as observer of the passed dataSet and act as the details in a master/details scenario\r\n\t *\r\n\t * @param {luga.data.DetailSet.options} options\r\n\t * @constructor\r\n\t * @extends luga.Notifier\r\n\t * @fires dataChanged\r\n\t * @listens dataChanged\r\n\t * @listens currentRowChanged\r\n\t */\r\n\tluga.data.DetailSet = function(options){\r\n\r\n\t\tvar CONST = {\r\n\t\t\tERROR_MESSAGES: {\r\n\t\t\t\tINVALID_ID_PARAMETER: \"Luga.DetailSet: id parameter is required\",\r\n\t\t\t\tINVALID_DS_PARAMETER: \"Luga.DetailSet: dataSet parameter is required\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif(options.id === undefined){\r\n\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ID_PARAMETER);\r\n\t\t}\r\n\t\tif(options.dataSet === undefined){\r\n\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_DS_PARAMETER);\r\n\t\t}\r\n\r\n\t\tluga.extend(luga.Notifier, this);\r\n\r\n\t\t/** @type {luga.data.DetailSet} */\r\n\t\tvar self = this;\r\n\r\n\t\tthis.id = options.id;\r\n\t\tthis.dataSet = options.dataSet;\r\n\t\tthis.dataSet.addObserver(this);\r\n\r\n\t\t/** @type {luga.data.DataSet.row} */\r\n\t\tthis.row = null;\r\n\r\n\t\tluga.data.setDataSource(this.id, this);\r\n\r\n\t\t/**\r\n\t\t * @returns {luga.data.DataSet.row}\r\n\t\t */\r\n\t\tthis.getContext = function(){\r\n\t\t\treturn this.row;\r\n\t\t};\r\n\r\n\t\tthis.fetchRow = function(){\r\n\t\t\tself.row = self.dataSet.getCurrentRow();\r\n\t\t\tthis.notifyObservers(luga.data.CONST.EVENTS.DATA_CHANGED, {dataSource: this});\r\n\t\t};\r\n\r\n\t\t/* Events Handlers */\r\n\r\n\t\t/**\r\n\t\t * @param {luga.data.dataSourceChanged} data\r\n\t\t */\r\n\t\tthis.onDataChangedHandler = function(data){\r\n\t\t\tself.fetchRow();\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * @param {luga.data.DataSet.currentRowChanged} data\r\n\t\t */\r\n\t\tthis.onCurrentRowChangedHandler = function(data){\r\n\t\t\tself.fetchRow();\r\n\t\t};\r\n\r\n\t\t/* Constructor */\r\n\r\n\t\tthis.fetchRow();\r\n\r\n\t};\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.DataSet.loading\r\n\t *\r\n\t * @property {luga.data.DataSet} dataSet\r\n\t */\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.HttpDataSet.xhrError\r\n\t *\r\n\t * @property {string} message\r\n\t * @property {object} jqXHR        jQuery wrapper around XMLHttpRequest\r\n\t * @property {string} textStatus\r\n\t * @property {string} errorThrown\r\n\t */\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.HttpDataSet.options\r\n\t *\r\n\t * @extends luga.data.DataSet.options\r\n\t * @property {string|null}   url       URL to be fetched. Default to null\r\n\t * @property {number}        timeout   Timeout (in milliseconds) for the HTTP request. Default to 10 seconds\r\n\t * @property {boolean}       cache     If set to false, it will force requested pages not to be cached by the browser.\r\n\t *                                     It works by appending \"_={timestamp}\" to the querystring. Default to true\r\n\t */\r\n\r\n\t/**\r\n\t * Base HttpDataSet class\r\n\t * @param luga.data.HttpDataSet.options\r\n\t * @constructor\r\n\t * @extends luga.data.DataSet\r\n\t * @abstract\r\n\t * @fires loading\r\n\t * @fires xhrError\r\n\t * @throws\r\n\t */\r\n\tluga.data.HttpDataSet = function(options){\r\n\t\tluga.extend(luga.data.DataSet, this, [options]);\r\n\t\t/** @type {luga.data.HttpDataSet} */\r\n\t\tvar self = this;\r\n\r\n\t\tvar CONST = {\r\n\t\t\tERROR_MESSAGES: {\r\n\t\t\t\tHTTP_DATA_SET_ABSTRACT: \"luga.data.HttpDataSet is an abstract class\",\r\n\t\t\t\tXHR_FAILURE: \"Failed to retrieve: {0}. HTTP status: {1}. Error: {2}\",\r\n\t\t\t\tNEED_URL_TO_LOAD: \"Unable to call loadData(). DataSet is missing a URL\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif(this.constructor === luga.data.HttpDataSet){\r\n\t\t\tthrow(CONST.ERROR_MESSAGES.HTTP_DATA_SET_ABSTRACT);\r\n\t\t}\r\n\r\n\t\tthis.url = null;\r\n\t\tif(options.url !== undefined){\r\n\t\t\tthis.url = options.url;\r\n\t\t}\r\n\r\n\t\tthis.timeout = luga.data.CONST.XHR_TIMEOUT;\r\n\t\tif(options.timeout !== undefined){\r\n\t\t\tthis.timeout = options.timeout;\r\n\t\t}\r\n\r\n\t\tthis.cache = true;\r\n\t\tif(options.cache !== undefined){\r\n\t\t\tthis.cache = options.cache;\r\n\t\t}\r\n\t\t// Concrete implementations can override this\r\n\t\tthis.dataType = null;\r\n\t\tthis.xhrRequest = null;\r\n\r\n\t\t/* Private methods */\r\n\r\n\t\tvar loadUrl = function(){\r\n\t\t\tvar xhrOptions = {\r\n\t\t\t\turl: self.url,\r\n\t\t\t\tsuccess: self.loadRecords,\r\n\t\t\t\ttimeout: self.timeout,\r\n\t\t\t\tcache: self.cache,\r\n\t\t\t\terror: self.xhrError\r\n\t\t\t};\r\n\t\t\tif(self.dataType !== null){\r\n\t\t\t\txhrOptions.dataType = self.dataType;\r\n\t\t\t}\r\n\t\t\tself.xhrRequest = jQuery.ajax(xhrOptions);\r\n\t\t};\r\n\r\n\t\t/* Public methods */\r\n\r\n\t\t/**\r\n\t\t * Abort any pending XHR request\r\n\t\t */\r\n\t\tthis.cancelRequest = function(){\r\n\t\t\tif(this.xhrRequest !== null){\r\n\t\t\t\tthis.xhrRequest.abort();\r\n\t\t\t\tthis.xhrRequest = null;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the URL that will be used to fetch the data. Returns null if URL is not set\r\n\t\t * @returns {string|null}\r\n\t\t */\r\n\t\tthis.getUrl = function(){\r\n\t\t\treturn this.url;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Fires off XHR request to fetch and load the data, notify observers (\"loading\" first, \"dataChanged\" after records are loaded).\r\n\t\t * Does nothing if URL is not set\r\n\t\t * @fires loading\r\n\t\t * @throws\r\n\t\t */\r\n\t\tthis.loadData = function(){\r\n\t\t\tif(this.url === null){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.NEED_URL_TO_LOAD);\r\n\t\t\t}\r\n\t\t\tthis.notifyObservers(luga.data.CONST.EVENTS.LOADING, {dataSet: this});\r\n\t\t\tthis.cancelRequest();\r\n\t\t\tthis.delete();\r\n\t\t\tloadUrl();\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Abstract method, child classes must implement it to extract records from XHR response\r\n\t\t * @param {*}        response     Data returned from the server\r\n\t\t * @param {string}   textStatus   HTTP status\r\n\t\t * @param {object}   jqXHR        jQuery wrapper around XMLHttpRequest\r\n\t\t * @abstract\r\n\t\t */\r\n\t\tthis.loadRecords = function(response, textStatus, jqXHR){\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Set the URL that will be used to fetch the data.\r\n\t\t * This method does not load the data into the data set, it merely sets the internal URL.\r\n\t\t * The developer must call loadData() to actually trigger the data loading\r\n\t\t * @param {string} newUrl\r\n\t\t */\r\n\t\tthis.setUrl = function(newUrl){\r\n\t\t\tthis.url = newUrl;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Is called whenever an XHR request fails, notify observers (\"xhrError\")\r\n\t\t * @param {object}   jqXHR        jQuery wrapper around XMLHttpRequest\r\n\t\t * @param {string}   textStatus   HTTP status\r\n\t\t * @param {string}   errorThrown  Error message from jQuery\r\n\t\t * @fires xhrError\r\n\t\t */\r\n\t\tthis.xhrError = function(jqXHR, textStatus, errorThrown){\r\n\t\t\tself.notifyObservers(luga.data.CONST.EVENTS.XHR_ERROR, {\r\n\t\t\t\tdataSet: self,\r\n\t\t\t\tmessage: luga.string.format(CONST.ERROR_MESSAGES.XHR_FAILURE, [self.url, jqXHR.status, errorThrown]),\r\n\t\t\t\tjqXHR: jqXHR,\r\n\t\t\t\ttextStatus: textStatus,\r\n\t\t\t\terrorThrown: errorThrown\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.JsonDataSet.options\r\n\t *\r\n\t * @extends luga.data.HttpDataSet.options\r\n\t * @property {string|null}   path      Specifies the path to the data within the JSON structure. Default to null\r\n\t */\r\n\r\n\t/**\r\n\t * JSON dataSet class\r\n\t * @param {luga.data.JsonDataSet.options} options\r\n\t * @constructor\r\n\t * @extends luga.data.HttpDataSet\r\n\t */\r\n\tluga.data.JsonDataSet = function(options){\r\n\t\tluga.extend(luga.data.HttpDataSet, this, [options]);\r\n\t\t/** @type {luga.data.JsonDataSet} */\r\n\t\tvar self = this;\r\n\t\t/** @override */\r\n\t\tthis.dataType = \"json\";\r\n\r\n\t\tthis.path = null;\r\n\t\tif(options.path !== undefined){\r\n\t\t\tthis.path = options.path;\r\n\t\t}\r\n\r\n\t\t/* Public methods */\r\n\r\n\t\t/**\r\n\t\t * Returns the path to be used to extract data out of the JSON data structure\r\n\t\t * @returns {string|null}\r\n\t\t */\r\n\t\tthis.getPath = function(){\r\n\t\t\treturn this.path;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Receives HTTP response, extracts and loads records out of it\r\n\t\t * @param {*}        response     Data returned from the server\r\n\t\t * @param {string}   textStatus   HTTP status\r\n\t\t * @param {object}   jqXHR        jQuery wrapper around XMLHttpRequest\r\n\t\t * @override\r\n\t\t */\r\n\t\tthis.loadRecords = function(response, textStatus, jqXHR){\r\n\t\t\tif(self.path === null){\r\n\t\t\t\tself.insert(response);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tif(response[self.path] !== undefined){\r\n\t\t\t\t\tself.insert(response[self.path]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Set the path to be used to extract data out of the JSON data structure\r\n\t\t * @param {string} path\r\n\t\t */\r\n\t\tthis.setPath = function(path){\r\n\t\t\tthis.path = path;\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * @typedef {object} luga.data.Region.options\r\n\t *\r\n\t * @property {jquery} node  Either a jQuery object wrapping the node or the naked DOM object that will contain the region. Required\r\n\t *\r\n\t */\r\n\r\n\t/**\r\n\t * Data Region class\r\n\t * @param {luga.data.Region.options} options\r\n\t * @listens dataChanged\r\n\t * @throws\r\n\t */\r\n\tluga.data.Region = function(options){\r\n\t\tif(typeof(Handlebars) === \"undefined\"){\r\n\t\t\tthrow(\"Unable to find Handlebars\");\r\n\t\t}\r\n\r\n\t\tvar self = this;\r\n\r\n\t\tthis.node = jQuery(options.node);\r\n\t\tthis.dsId = this.node.attr(luga.data.CONST.CUSTOM_ATTRIBUTES.DATA_SOURCE);\r\n\t\t/** @type {luga.data.DataSet|luga.data.DetailSet} */\r\n\t\tthis.dataSource = luga.data.getDataSource(this.dsId);\r\n\t\tthis.dataSource.addObserver(this);\r\n\r\n\t\tthis.templateId = this.node.attr(luga.data.CONST.CUSTOM_ATTRIBUTES.TEMPLATE);\r\n\t\tif(this.templateId !== undefined){\r\n\t\t\tthis.template = Handlebars.compile(jQuery(\"#\" + this.templateId).html());\r\n\t\t}\r\n\t\telse{\r\n\t\t\tthis.template = Handlebars.compile(this.node.html());\r\n\t\t}\r\n\r\n\t\tthis.generateHtml = function(){\r\n\t\t\treturn this.template(this.dataSource.getContext());\r\n\t\t};\r\n\r\n\t\tthis.render = function(){\r\n\t\t\tthis.node.html(this.generateHtml());\r\n\t\t};\r\n\r\n\t\t/* Events Handlers */\r\n\r\n\t\t/**\r\n\t\t * @param {luga.data.dataSourceChanged} data\r\n\t\t */\r\n\t\tthis.onDataChangedHandler = function(data){\r\n\t\t\tself.render();\r\n\t\t};\r\n\t};\r\n\r\n\tjQuery(document).ready(function(){\r\n\t\tjQuery(luga.data.CONST.SELECTORS.REGION).each(function(index, item){\r\n\t\t\tnew luga.data.Region({\r\n\t\t\t\tnode: jQuery(item)\r\n\t\t\t});\r\n\t\t});\r\n\t});\r\n\r\n}());"],"sourceRoot":"."}