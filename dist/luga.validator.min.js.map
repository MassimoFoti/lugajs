{"version":3,"sources":["luga.validator.js"],"names":["isNumeric","input","isNaN","parseFloat","isFinite","luga","namespace","validator","handlers","errorAlert","formNode","validators","errorMsg","focusGiven","i","length","message","getFocus","alert","errorBox","utils","removeDisplayBox","htmlStr","name","displayErrorMessage","CONST","FORM_SELECTOR","RULE_PREFIX","DEFAULT_DATE_PATTERN","CUSTOM_ATTRIBUTES","VALIDATE","ERROR","BEFORE","AFTER","BLOCK_SUBMIT","MESSAGE","ERROR_CLASS","REQUIRED","PATTERN","MIN_LENGTH","MAX_LENGTH","MIN_NUMBER","MAX_NUMBER","DATE_PATTERN","MIN_DATE","MAX_DATE","EQUAL_TO","MIN_CHECKED","MAX_CHECKED","INVALID_INDEX","INVALID_VALUE","DISABLED_MESSAGE","MESSAGES","MISSING_FORM","MISSING_FIELD","MISSING_FUNCTION","BASE_VALIDATOR_ABSTRACT","GROUP_VALIDATOR_ABSTRACT","FIELD_CANT_BE_VALIDATED","PATTERN_NOT_FOUND","INVALID_INDEX_PARAMETER","MISSING_EQUAL_TO_FIELD","HANDLERS","FORM_ERROR","FormValidator","options","this","config","blocksubmit","getAttribute","error","before","after","merge","JSON","parse","self","dirtyValidators","init","formDom","elements","form","isInputField","push","fieldValidatorFactory","getInstance","fieldNode","validate","event","executedValidators","undefined","isValid","preventDefault","disableSubmit","buttons","querySelectorAll","buttonNode","value","callBack","lookupFunction","string","format","apply","type","SelectValidator","RadioValidator","inputGroup","getFieldGroup","CheckboxValidator","TextValidator","BaseFieldValidator","constructor","errorclass","node","flagInvalid","classList","add","setAttribute","flagValid","remove","removeAttribute","disabled","required","pattern","minlength","maxlength","minnumber","maxnumber","datepattern","mindate","maxdate","equalto","extend","e","focus","select","isEmpty","isRequired","requiredAtt","functionReference","rule","rules","invalidindex","invalidvalue","currentIndex","selectedIndex","parseInt","BaseGroupValidator","field","requiredFlag","fieldGroup","checked","minchecked","maxchecked","checkCounter","email","fieldValue","containsAt","indexOf","containDot","secondFieldNode","document","getElementById","dateStrToObj","valueDate","maxDate","minDate","regExpObj","patterns","test","lettersonly","RegExp","alphanumeric","integer","positiveinteger","number","filepath_pdf","filepath_jpg","filepath_zip","filepath","time","createDateSpecObj","rex","year","month","day","separator","infoObj","y","m","d","s","dateStr","dateSpecKey","dateSpecObj","dateSpecs","dateBits","split","testDate","Date","yearMatches","getFullYear","monthMatches","getMonth","dayMatches","getDate","initForms","rootNode","body","nodes","element","addEventListener","CSS_CLASSES","ERROR_MESSAGE","MSG_BOX_ID","generateBoxId","boxId","oldBox","outerHTML","displayMessage","html","displayBox","cssClass","box","createElement","innerHTML","insertBefore","api","validateForm","formValidator","validateField","fieldValidator","validateFields","fields","j","validateChildFields","getChildFields","dom","ready"],"mappings":"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","file":"luga.validator.min.js","sourcesContent":["/*! \nLuga Validator 0.9.7 2018-04-08T09:40:04.747Z\nhttp://www.lugajs.org\nCopyright 2013-2018 Massimo Foti (massimo@massimocorner.com)\nLicensed under the Apache License, Version 2.0 | http://www.apache.org/licenses/LICENSE-2.0\n */\n/* globals alert */\r\n\r\n/* istanbul ignore if */\r\nif(typeof(luga) === \"undefined\"){\r\n\tthrow(\"Unable to find Luga JS Common\");\r\n}\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Helper function\r\n\t * @param {*} input\r\n\t * @returns {Boolean}\r\n\t */\r\n\tconst isNumeric = function(input){\r\n\t\treturn (isNaN(parseFloat(input)) === false) && (isFinite(input) === true);\r\n\t};\r\n\r\n\tluga.namespace(\"luga.validator\");\r\n\r\n\t/* Validation handlers */\r\n\r\n\tluga.namespace(\"luga.validator.handlers\");\r\n\r\n\t/**\r\n\t * Display error messages inside alert\r\n\t *\r\n\t * @param {HTMLElement}                                 formNode      DOM node\r\n\t * @param {Array.<luga.validator.BaseFieldValidator>}   validators    Array of field validators\r\n\t */\r\n\tluga.validator.handlers.errorAlert = function(formNode, validators){\r\n\t\tlet errorMsg = \"\";\r\n\t\tlet focusGiven = false;\r\n\t\tfor(let i = 0; i < validators.length; i++){\r\n\t\t\t// Append to the error string\r\n\t\t\terrorMsg += validators[i].message + \"\\n\";\r\n\t\t\t// Give focus to the first invalid text field\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif((focusGiven === false) && (validators[i].getFocus)){\r\n\t\t\t\tvalidators[i].getFocus();\r\n\t\t\t\tfocusGiven = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t/* istanbul ignore else */\r\n\t\tif(errorMsg !== \"\"){\r\n\t\t\talert(errorMsg);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Display errors inside a box above the form\r\n\t *\r\n\t * @param {HTMLElement}                                 formNode      DOM node\r\n\t * @param {Array.<luga.validator.BaseFieldValidator>}   validators    Array of field validators\r\n\t */\r\n\tluga.validator.handlers.errorBox = function(formNode, validators){\r\n\t\t// Clean-up any existing box\r\n\t\tif(validators.length === 0){\r\n\t\t\tluga.validator.utils.removeDisplayBox(formNode);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet focusGiven = false;\r\n\t\tlet htmlStr = \"<ul>\";\r\n\t\t// Create a <ul> for each error\r\n\t\tfor(let i = 0; i < validators.length; i++){\r\n\t\t\thtmlStr += \"<li><em>\" + validators[i].name + \": </em> \" + validators[i].message + \"</li>\";\r\n\t\t\t// Give focus to the first invalid text field\r\n\t\t\tif((focusGiven === false) && (validators[i].getFocus)){\r\n\t\t\t\tvalidators[i].getFocus();\r\n\t\t\t\tfocusGiven = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\thtmlStr += \"</ul>\";\r\n\t\tluga.validator.utils.displayErrorMessage(formNode, htmlStr);\r\n\t};\r\n\r\n\tluga.validator.CONST = {\r\n\t\tFORM_SELECTOR: \"form[data-lugavalidator-validate]\",\r\n\t\tRULE_PREFIX: \"data-lugavalidator-\",\r\n\t\tDEFAULT_DATE_PATTERN: \"YYYY-MM-DD\",\r\n\t\tCUSTOM_ATTRIBUTES: {\r\n\t\t\tVALIDATE: \"data-lugavalidator-validate\",\r\n\t\t\tERROR: \"data-lugavalidator-error\",\r\n\t\t\tBEFORE: \"data-lugavalidator-before\",\r\n\t\t\tAFTER: \"data-lugavalidator-after\",\r\n\t\t\tBLOCK_SUBMIT: \"data-lugavalidator-blocksubmit\",\r\n\t\t\tMESSAGE: \"data-lugavalidator-message\",\r\n\t\t\tERROR_CLASS: \"data-lugavalidator-errorclass\",\r\n\t\t\tREQUIRED: \"data-lugavalidator-required\",\r\n\t\t\tPATTERN: \"data-lugavalidator-pattern\",\r\n\t\t\tMIN_LENGTH: \"data-lugavalidator-minlength\",\r\n\t\t\tMAX_LENGTH: \"data-lugavalidator-maxlength\",\r\n\t\t\tMIN_NUMBER: \"data-lugavalidator-minnumber\",\r\n\t\t\tMAX_NUMBER: \"data-lugavalidator-maxnumber\",\r\n\t\t\tDATE_PATTERN: \"data-lugavalidator-datepattern\",\r\n\t\t\tMIN_DATE: \"data-lugavalidator-mindate\",\r\n\t\t\tMAX_DATE: \"data-lugavalidator-maxdate\",\r\n\t\t\tEQUAL_TO: \"data-lugavalidator-equalto\",\r\n\t\t\tMIN_CHECKED: \"data-lugavalidator-minchecked\",\r\n\t\t\tMAX_CHECKED: \"data-lugavalidator-maxchecked\",\r\n\t\t\tINVALID_INDEX: \"data-lugavalidator-invalidindex\",\r\n\t\t\tINVALID_VALUE: \"data-lugavalidator-invalidvalue\",\r\n\t\t\tDISABLED_MESSAGE: \"data-lugavalidator-disabledlabel\"\r\n\t\t},\r\n\t\tMESSAGES: {\r\n\t\t\tMISSING_FORM: \"luga.validator was unable to load form\",\r\n\t\t\tMISSING_FIELD: \"luga.validator was unable to load field\",\r\n\t\t\tMISSING_FUNCTION: \"luga.validator was unable to find a function named: {0}\",\r\n\t\t\tBASE_VALIDATOR_ABSTRACT: \"luga.validator.BaseFieldValidator is an abstract class\",\r\n\t\t\tGROUP_VALIDATOR_ABSTRACT: \"luga.validator.BaseGroupValidator is an abstract class\",\r\n\t\t\tFIELD_CANT_BE_VALIDATED: \"This field can't be validated\",\r\n\t\t\tPATTERN_NOT_FOUND: \"luga.validator failed to retrieve pattern: {0}\",\r\n\t\t\tINVALID_INDEX_PARAMETER: \"data-lugavalidator-invalidindex accept only numbers\",\r\n\t\t\tMISSING_EQUAL_TO_FIELD: \"data-lugavalidator-equalto was unable to find field with id = {0}\"\r\n\t\t},\r\n\t\tHANDLERS: {\r\n\t\t\tFORM_ERROR: \"luga.validator.handlers.errorAlert\"\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.validator.FormValidator.options\r\n\t *\r\n\t * @property {HTMLElement}  formNode      DOM node. Required\r\n\t * @property {String}  error         Name of the function to be invoked to handle/display validation messages.\r\n\t *                                   Default to luga.validator.errorAlert\r\n\t * @property {String}  before        Name of the function to be invoked before validation is performed. Default to null\r\n\t * @property {String}  after         Name of the function to be invoked after validation is performed. Default to null\r\n\t * @property {Boolean} blocksubmit   Disable submit buttons if the form isn't valid\r\n\t *                                   This prevents multiple submits but also prevents the value of the submit buttons from being passed as part of the HTTP request\r\n\t *                                   Set this options to false to keep the submit buttons enabled\r\n\t */\r\n\r\n\t/**\r\n\t * Form validator class\r\n\t *\r\n\t * @constructor\r\n\t * @param {luga.validator.FormValidator.options} options\r\n\t * @throw {Exception}\r\n\t */\r\n\tluga.validator.FormValidator = function(options){\r\n\r\n\t\tif(options.formNode === null){\r\n\t\t\tthrow(luga.validator.CONST.MESSAGES.MISSING_FORM);\r\n\t\t}\r\n\r\n\t\t/** @type {luga.validator.FormValidator.options} */\r\n\t\tthis.config = {\r\n\t\t\t// Either: custom attribute, incoming option or default\r\n\t\t\tblocksubmit: options.formNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.BLOCK_SUBMIT) || \"true\",\r\n\t\t\terror: options.formNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.ERROR) || luga.validator.CONST.HANDLERS.FORM_ERROR,\r\n\t\t\t// Either: custom attribute, incoming option or null\r\n\t\t\tbefore: options.formNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.BEFORE) || null,\r\n\t\t\tafter: options.formNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.AFTER) || null\r\n\t\t};\r\n\t\tluga.merge(this.config, options);\r\n\t\t// Hack to ensure it's a boolean\r\n\t\tthis.config.blocksubmit = JSON.parse(this.config.blocksubmit);\r\n\r\n\t\t/** @type {luga.validator.FormValidator} */\r\n\t\tconst self = this;\r\n\t\t/** @type {Array.<luga.validator.BaseFieldValidator>} */\r\n\t\tself.validators = [];\r\n\t\t/** @type {Array.<luga.validator.BaseFieldValidator>} */\r\n\t\tself.dirtyValidators = [];\r\n\r\n\t\tthis.init = function(){\r\n\t\t\tself.validators = [];\r\n\t\t\tself.dirtyValidators = [];\r\n\t\t\tconst formDom = self.config.formNode;\r\n\t\t\tfor(let i = 0; i < formDom.elements.length; i++){\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif(luga.form.utils.isInputField(formDom.elements[i]) === true){\r\n\t\t\t\t\tself.validators.push(luga.validator.fieldValidatorFactory.getInstance({\r\n\t\t\t\t\t\tfieldNode: formDom.elements[i],\r\n\t\t\t\t\t\tformNode: self.config.formNode\r\n\t\t\t\t\t}));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Execute all field validators. Returns an array of field validators that are in invalid state\r\n\t\t * The returned array is empty if there are no errors\r\n\t\t *\r\n\t\t * @param   {Event} event\r\n\t\t * @return {Array.<luga.validator.BaseFieldValidator>}\r\n\t\t */\r\n\t\tthis.validate = function(event){\r\n\t\t\tself.init();\r\n\t\t\tself.before(self.config.formNode, event);\r\n\t\t\t// Keep track of already validated fields (to skip already validated checkboxes or radios)\r\n\t\t\tconst executedValidators = {};\r\n\t\t\tfor(let i = 0; i < self.validators.length; i++){\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif((self.validators[i] !== undefined) && (self.validators[i].validate !== undefined)){\r\n\t\t\t\t\tif(executedValidators[self.validators[i].name] !== undefined){\r\n\t\t\t\t\t\t// Already validated checkbox or radio, skip it\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(self.validators[i].validate() === true){\r\n\t\t\t\t\t\tself.dirtyValidators.push(self.validators[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\texecutedValidators[self.validators[i].name] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(self.isValid() === false){\r\n\t\t\t\tself.error();\r\n\t\t\t\tif(event !== undefined){\r\n\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tif(this.config.blocksubmit === true){\r\n\t\t\t\t\t// Disable submit buttons to avoid multiple submits\r\n\t\t\t\t\tself.disableSubmit();\r\n\t\t\t\t}\r\n\t\t\t\tself.after(self.config.formNode, event);\r\n\t\t\t}\r\n\t\t\treturn self.dirtyValidators;\r\n\t\t};\r\n\r\n\t\tthis.disableSubmit = function(){\r\n\t\t\tconst buttons = self.config.formNode.querySelectorAll(\"input[type=submit]\");\r\n\t\t\tfor(let i = 0; i < buttons.length; i++){\r\n\t\t\t\tconst buttonNode = buttons[i];\r\n\t\t\t\tif(buttonNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.DISABLED_MESSAGE) !== null){\r\n\t\t\t\t\tbuttonNode.value = buttonNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.DISABLED_MESSAGE);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns truue if the form is valid, false otherwise\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tthis.isValid = function(){\r\n\t\t\treturn self.dirtyValidators.length === 0;\r\n\t\t};\r\n\r\n\t\tthis.before = function(formNode, event){\r\n\t\t\tif(self.config.before !== null){\r\n\t\t\t\tconst callBack = luga.lookupFunction(self.config.before);\r\n\t\t\t\tif(callBack !== undefined){\r\n\t\t\t\t\tcallBack.apply(null, [self.config.formNode, event]);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tthrow(luga.string.format(luga.validator.CONST.MESSAGES.MISSING_FUNCTION, [self.config.before]));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.error = function(){\r\n\t\t\tconst callBack = luga.lookupFunction(self.config.error);\r\n\t\t\tif(callBack !== undefined){\r\n\t\t\t\tcallBack.apply(null, [self.config.formNode, self.dirtyValidators]);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tthrow(luga.string.format(luga.validator.CONST.MESSAGES.MISSING_FUNCTION, [self.config.error]));\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.after = function(formNode, event){\r\n\t\t\tif(self.config.after !== null){\r\n\t\t\t\tconst callBack = luga.lookupFunction(self.config.after);\r\n\t\t\t\tif(callBack !== undefined){\r\n\t\t\t\t\tcallBack.apply(null, [self.config.formNode, event]);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tthrow(luga.string.format(luga.validator.CONST.MESSAGES.MISSING_FUNCTION, [self.config.after]));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t};\r\n\r\n\tluga.namespace(\"luga.validator.fieldValidatorFactory\");\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.validator.fieldValidatorFactory.getInstance.options\r\n\t *\r\n\t * @property {HTMLElement|undefined} formNode    The form DOM object\r\n\t *                                               Required in case of radio and checkboxes (that are validated as group), optional in all other cases\r\n\r\n\t * @property {HTMLElement} fieldNode             The field DOM object. Required\r\n\t *\r\n\t * Additional options can be used, but are specific to different kind of input fields.\r\n\t * Check their implementation for details\r\n\t */\r\n\r\n\t/**\r\n\t * Field validator factory. Use this to instantiate a field validator without worrying about the specific implementation\r\n\t *\r\n\t * @param {luga.validator.fieldValidatorFactory.getInstance.options} options\r\n\t * @return {luga.validator.BaseFieldValidator|luga.validator.BaseGroupValidator}\r\n\t */\r\n\tluga.validator.fieldValidatorFactory.getInstance = function(options){\r\n\t\t/** @type {luga.validator.fieldValidatorFactory.getInstance.options} */\r\n\t\tthis.config = {};\r\n\t\tluga.merge(this.config, options);\r\n\t\tconst self = this;\r\n\t\t// Abort if the field isn't suitable to validation\r\n\t\tif(luga.form.utils.isInputField(self.config.fieldNode) === false){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tconst fieldType = this.config.fieldNode.type;\r\n\t\t// Get relevant validator based on field type\r\n\t\tswitch(fieldType){\r\n\r\n\t\t\tcase \"select-multiple\":\r\n\t\t\t\treturn new luga.validator.SelectValidator(this.config);\r\n\r\n\t\t\tcase \"select-one\":\r\n\t\t\t\treturn new luga.validator.SelectValidator(this.config);\r\n\r\n\t\t\tcase \"radio\":\r\n\t\t\t\treturn new luga.validator.RadioValidator({\r\n\t\t\t\t\tinputGroup: luga.form.utils.getFieldGroup(this.config.fieldNode.name, this.config.formNode)\r\n\t\t\t\t});\r\n\r\n\t\t\tcase \"checkbox\":\r\n\t\t\t\treturn new luga.validator.CheckboxValidator({\r\n\t\t\t\t\tinputGroup: luga.form.utils.getFieldGroup(this.config.fieldNode.name, this.config.formNode)\r\n\t\t\t\t});\r\n\r\n\t\t\tdefault:\r\n\t\t\t\treturn new luga.validator.TextValidator(this.config);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.validator.BaseFieldValidator.options\r\n\t *\r\n\t * @property {HTMLElement} fieldNode    Field DOM object. Required\r\n\t * @property {String} message           Error message. Can also be set using the \"data-lugavalidator-message\" attribute. Optional\r\n\t * @property {String} errorclass        CSS class to apply for invalid state. Can also be set using the \"data-lugavalidator-errorclass\" attribute. Optional\r\n\t *\r\n\t * Additional options can be used, but are specific to different kind of input fields.\r\n\t * Check their implementation for details\r\n\t */\r\n\r\n\t/**\r\n\t * Abstract field validator class. To be extended for different kind of fields\r\n\t *\r\n\t * @constructor\r\n\t * @abstract\r\n\t * @param {luga.validator.BaseFieldValidator.options} options\r\n\t * @throw {Exception}\r\n\t */\r\n\tluga.validator.BaseFieldValidator = function(options){\r\n\r\n\t\tif(this.constructor === luga.validator.BaseFieldValidator){\r\n\t\t\tthrow(luga.validator.CONST.MESSAGES.BASE_VALIDATOR_ABSTRACT);\r\n\t\t}\r\n\r\n\t\t/** @type {luga.validator.BaseFieldValidator.options} */\r\n\t\tthis.config = {\r\n\t\t\tmessage: options.fieldNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.MESSAGE) || \"\",\r\n\t\t\terrorclass: options.fieldNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.ERROR_CLASS) || \"\"\r\n\t\t};\r\n\t\tluga.merge(this.config, options);\r\n\r\n\t\tthis.node = options.fieldNode;\r\n\t\tthis.message = this.config.message;\r\n\t\tthis.name = \"\";\r\n\r\n\t\tif(this.node.getAttribute(\"name\") !== null){\r\n\t\t\tthis.name = this.node.getAttribute(\"name\");\r\n\t\t}\r\n\t\telse if(this.node.getAttribute(\"id\") !== null){\r\n\t\t\tthis.name = this.node.getAttribute(\"id\");\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Return true if the field is valid. False otherwise\r\n\t\t * @abstract\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\t/* istanbul ignore next */\r\n\t\tthis.isValid = function(){\r\n\t\t};\r\n\r\n\t\tthis.flagInvalid = function(){\r\n\t\t\tif(this.config.errorclass !== \"\"){\r\n\t\t\t\tthis.node.classList.add(this.config.errorclass);\r\n\t\t\t}\r\n\t\t\t// Set the title attribute in order to show a tooltip\r\n\t\t\tthis.node.setAttribute(\"title\", this.message);\r\n\t\t};\r\n\r\n\t\tthis.flagValid = function(){\r\n\t\t\tif(this.config.errorclass !== \"\"){\r\n\t\t\t\tthis.node.classList.remove(this.config.errorclass);\r\n\t\t\t}\r\n\t\t\tthis.node.removeAttribute(\"title\");\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Be careful, this method returns a boolean but also has side-effects\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tthis.validate = function(){\r\n\t\t\t// Disabled fields are always valid\r\n\t\t\tif(this.node.disabled === true){\r\n\t\t\t\tthis.flagValid();\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif(this.isValid() === false){\r\n\t\t\t\tthis.flagInvalid();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tthis.flagValid();\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.validator.TextValidator.options\r\n\t *\r\n\t * @property {HTMLElement} fieldNode          DOM object. Required\r\n\t * @property {boolean|function} required      Set it to true to flag the field as required.\r\n\t *                                            In case you need conditional validation, set it to the name of a custom function that will handle the condition.\r\n\t *                                            Can also be set using the \"data-lugavalidator-required\" attribute. Optional\r\n\t * @property {String} pattern                 Validation pattern to be applied, either built-in or custom.\r\n\t *                                            Can also be set using the \"data-lugavalidator-pattern\" attribute. Optional\r\n\t * @property {String} minlength               Enforce a minimum text length. Can also be set using the \"data-lugavalidator-minlength\" attribute. Optional\r\n\t * @property {String} maxlength               Enforce a maximum text length. Can also be set using the \"data-lugavalidator-maxlength\" attribute. Optional\r\n\t * @property {String} minnumber               Enforce a minimum numeric value. Can also be set using the \"data-lugavalidator-minnumber\" attribute. Optional\r\n\t * @property {String} maxnumber               Enforce a maximum numeric value. Can also be set using the \"data-lugavalidator-maxnumber\" attribute. Optional\r\n\t * @property {String} datepattern             Date format pattern to be applied, either built-in or custom. Can also be set using the \"data-lugavalidator-datepattern\" attribute. Optional\r\n\t * @property {String} mindate                 Enforce a minimum date. Can also be set using the \"data-lugavalidator-mindate\" attribute. Optional\r\n\t * @property {String} maxdate                 Enforce a maximum date. Can also be set using the \"data-lugavalidator-maxdate\" attribute. Optional\r\n\t * @property {String} equalto                 Id of another field who's values will be compared for equality. Can also be set using the \"data-lugavalidator-equalto\" attribute. Optional\r\n\t * @property {String} message                 Error message. Can also be set using the \"data-lugavalidator-message\" attribute. Optional\r\n\t * @property {String} errorclass              CSS class to apply for invalid state. Can also be set using the \"data-lugavalidator-errorclass\" attribute. Optional\r\n\t */\r\n\r\n\t/**\r\n\t * Text field validator class\r\n\t *\r\n\t * @constructor\r\n\t * @extend luga.validator.BaseFieldValidator\r\n\t * @param {luga.validator.TextValidator.options} options\r\n\t * @throw {Exception}\r\n\t */\r\n\tluga.validator.TextValidator = function(options){\r\n\r\n\t\tif(options.fieldNode === null){\r\n\t\t\tthrow(luga.validator.CONST.MESSAGES.MISSING_FIELD);\r\n\t\t}\r\n\r\n\t\t/** @type {luga.validator.TextValidator.options} */\r\n\t\tthis.config = {\r\n\t\t\trequired: options.fieldNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.REQUIRED),\r\n\t\t\tpattern: options.fieldNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.PATTERN),\r\n\t\t\tminlength: options.fieldNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.MIN_LENGTH),\r\n\t\t\tmaxlength: options.fieldNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.MAX_LENGTH),\r\n\t\t\tminnumber: options.fieldNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.MIN_NUMBER),\r\n\t\t\tmaxnumber: options.fieldNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.MAX_NUMBER),\r\n\t\t\tdatepattern: options.fieldNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.DATE_PATTERN) || luga.validator.CONST.DEFAULT_DATE_PATTERN,\r\n\t\t\tmindate: options.fieldNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.MIN_DATE),\r\n\t\t\tmaxdate: options.fieldNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.MAX_DATE),\r\n\t\t\tequalto: options.fieldNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.EQUAL_TO)\r\n\t\t};\r\n\r\n\t\tluga.merge(this.config, options);\r\n\t\tluga.extend(luga.validator.BaseFieldValidator, this, [this.config]);\r\n\r\n\t\t/* istanbul ignore else */\r\n\t\tif(this.config.required !== undefined){\r\n\t\t\ttry{\r\n\t\t\t\t// Hack to ensure it's a boolean\r\n\t\t\t\tthis.config.required = JSON.parse(this.config.required);\r\n\t\t\t}\r\n\t\t\tcatch(e){\r\n\t\t\t\t// Unable to convert into a booolean. It must be a string referencing a function\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/** @type {luga.validator.TextValidator} */\r\n\t\tconst self = this;\r\n\r\n\t\tself.node = options.fieldNode;\r\n\t\tself.type = \"text\";\r\n\r\n\t\t// Put focus and cursor inside the field\r\n\t\tthis.getFocus = function(){\r\n\t\t\t// This try block is required to solve an obscure issue with IE and hidden fields\r\n\t\t\ttry{\r\n\t\t\t\tself.node.focus();\r\n\t\t\t\tself.node.select();\r\n\t\t\t}\r\n\t\t\tcatch(e){\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tthis.isEmpty = function(){\r\n\t\t\treturn self.node.value === \"\";\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tthis.isRequired = function(){\r\n\t\t\tconst requiredAtt = this.config.required;\r\n\t\t\tif(requiredAtt === true){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tif(requiredAtt === false || requiredAtt === null){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t// It's a conditional validation. Invoke the relevant function if available\r\n\t\t\tconst functionReference = luga.lookupFunction(requiredAtt);\r\n\t\t\tif(functionReference !== undefined){\r\n\t\t\t\treturn functionReference.apply(null, [self.node]);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tthrow(luga.string.format(luga.validator.CONST.MESSAGES.MISSING_FUNCTION, [requiredAtt]));\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns true if the field satisfy the rules associated with it. False otherwise\r\n\t\t * Be careful, this method contains multiple exit points!!!\r\n\t\t * @override\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tthis.isValid = function(){\r\n\t\t\tif(self.isEmpty()){\r\n\t\t\t\tif(self.isRequired() === true){\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\t// It's empty. Loop over all the available rules\r\n\t\t\t\tfor(let rule in luga.validator.rules){\r\n\t\t\t\t\t// Check if the current rule is required for the field\r\n\t\t\t\t\tif(self.node.getAttribute(luga.validator.CONST.RULE_PREFIX + rule) !== null){\r\n\t\t\t\t\t\t// Invoke the rule\r\n\t\t\t\t\t\tif(luga.validator.rules[rule].apply(null, [self.node, self]) === false){\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t};\r\n\t};\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.validator.SelectValidator.options\r\n\t *\r\n\t * @property {HTMLElement} fieldNode         DOM object. Required\r\n\t * @property {String|number} invalidindex    Prevents selection of an entry on a given position (zero based). Can also be set using the \"data-lugavalidator-invalidindex\" attribute. Optional\r\n\t * @property {String} invalidvalue           Prevents selection of an entry with a given value. Can also be set using the \"data-lugavalidator-invalidvalue\" attribute. Optional\r\n\t * @property {String} message                Error message. Can also be set using the \"data-lugavalidator-message\" attribute. Optional\r\n\t * @property {String} errorclass             CSS class to apply for invalid state. Can also be set using the \"data-lugavalidator-errorclass\" attribute. Optional\r\n\t */\r\n\r\n\t/**\r\n\t * Select field validator class\r\n\t *\r\n\t * @constructor\r\n\t * @extend luga.validator.BaseFieldValidator\r\n\t * @param {luga.validator.SelectValidator.options} options\r\n\t * @throw {Exception}\r\n\t */\r\n\tluga.validator.SelectValidator = function(options){\r\n\r\n\t\tif(options.fieldNode === null){\r\n\t\t\tthrow(luga.validator.CONST.MESSAGES.MISSING_FIELD);\r\n\t\t}\r\n\r\n\t\t/** @type {luga.validator.SelectValidator.options} */\r\n\t\tthis.config = {\r\n\t\t\tinvalidindex: options.fieldNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.INVALID_INDEX),\r\n\t\t\tinvalidvalue: options.fieldNode.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.INVALID_VALUE)\r\n\t\t};\r\n\r\n\t\tluga.merge(this.config, options);\r\n\t\tluga.extend(luga.validator.BaseFieldValidator, this, [this.config]);\r\n\r\n\t\t/** @type {luga.validator.SelectValidator} */\r\n\t\tconst self = this;\r\n\t\tself.type = \"select\";\r\n\t\tself.node = options.fieldNode;\r\n\r\n\t\t// Ensure invalidindex is numeric\r\n\t\tif((self.config.invalidindex !== null) && (isNumeric(self.config.invalidindex) === false)){\r\n\t\t\tthrow(luga.validator.CONST.MESSAGES.INVALID_INDEX_PARAMETER);\r\n\t\t}\r\n\r\n\t\t// Whenever a \"size\" attribute is available, the browser reports -1 as selectedIndex\r\n\t\t// Fix this weirdness\r\n\t\tlet currentIndex = self.node.selectedIndex;\r\n\t\tif(currentIndex === -1){\r\n\t\t\tcurrentIndex = 0;\r\n\t\t}\r\n\t\tcurrentIndex = parseInt(currentIndex, 10);\r\n\r\n\t\t/**\r\n\t\t * Returns true if the field satisfy the rules associated with it. False otherwise\r\n\t\t * Be careful, this method contains multiple exit points!!!\r\n\t\t * @override\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tthis.isValid = function(){\r\n\t\t\t// Check for index\r\n\t\t\tif(currentIndex === parseInt(self.config.invalidindex, 10)){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t// Check for value\r\n\t\t\tif(self.node.value === self.config.invalidvalue){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t// No need to care about other rules\r\n\t\t\treturn true;\r\n\t\t};\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.validator.BaseGroupValidator.options\r\n\t *\r\n\t * @property @property {Array.<HTMLElement>} inputGroup      An array of DOM nodes that share the same name. Use luga.form.utils.getFieldGroup() to obtain it. Required\r\n\t * @property {String} message                                Error message. Can also be set using the \"data-lugavalidator-message\" attribute. Optional\r\n\t * @property {String} errorclass                             CSS class to apply for invalid state. Can also be set using the \"data-lugavalidator-errorclass\" attribute. Optional\r\n\t *\r\n\t * Additional options can be used, but are specific to different kind of input fields.\r\n\t * Check their implementation for details\r\n\t */\r\n\r\n\t/**\r\n\t * Abstract validator class for grouped fields (checkboxes, radio buttons). To be extended for different kind of fields\r\n\t *\r\n\t * @constructor\r\n\t * @abstract\r\n\t * @param {luga.validator.BaseFieldValidator.options} options\r\n\t * @throw {Exception}\r\n\t */\r\n\tluga.validator.BaseGroupValidator = function(options){\r\n\r\n\t\tif(this.constructor === luga.validator.BaseGroupValidator){\r\n\t\t\tthrow(luga.validator.CONST.MESSAGES.GROUP_VALIDATOR_ABSTRACT);\r\n\t\t}\r\n\t\t/** @type {luga.validator.BaseFieldValidator.options} */\r\n\t\tthis.config = {};\r\n\t\tluga.merge(this.config, options);\r\n\t\tthis.inputGroup = this.config.inputGroup;\r\n\r\n\t\tif(this.config.inputGroup.length > 0 && this.config.inputGroup[0].getAttribute(\"name\") !== null){\r\n\t\t\t// Get the name of the first node\r\n\t\t\tthis.name = this.config.inputGroup[0].getAttribute(\"name\");\r\n\t\t}\r\n\r\n\t\tthis.message = \"\";\r\n\t\tthis.errorclass = \"\";\r\n\r\n\t\t// Since fields from the same group can have conflicting attribute values, the last one win\r\n\t\tfor(let i = 0; i < this.inputGroup.length; i++){\r\n\t\t\tconst field = this.inputGroup[i];\r\n\t\t\tif(field.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.MESSAGE) !== null){\r\n\t\t\t\tthis.message = field.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.MESSAGE);\r\n\t\t\t}\r\n\t\t\tif(field.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.ERROR_CLASS) !== null){\r\n\t\t\t\tthis.errorclass = field.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.ERROR_CLASS);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns true if the field group is valid. False otherwise\r\n\t\t * @abstract\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\t/* istanbul ignore next */\r\n\t\tthis.isValid = function(){\r\n\t\t};\r\n\r\n\t\tthis.flagInvalid = function(){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(this.errorclass !== \"\"){\r\n\t\t\t\tfor(let i = 0; i < this.inputGroup.length; i++){\r\n\t\t\t\t\tconst field = this.inputGroup[i];\r\n\t\t\t\t\tfield.classList.add(this.errorclass);\r\n\t\t\t\t\tfield.setAttribute(\"title\", this.message);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.flagValid = function(){\r\n\t\t\tif(this.errorclass !== \"\"){\r\n\t\t\t\tfor(let i = 0; i < this.inputGroup.length; i++){\r\n\t\t\t\t\tconst field = this.inputGroup[i];\r\n\t\t\t\t\tfield.classList.remove(this.errorclass);\r\n\t\t\t\t\tfield.removeAttribute(\"title\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Be careful, this method returns a boolean but also has side-effects\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tthis.validate = function(){\r\n\t\t\tif(this.isValid() === true){\r\n\t\t\t\tthis.flagValid();\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tthis.flagInvalid();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.validator.RadioValidator.options\r\n\t *\r\n\t * @property {Array.<HTMLElement>} inputGroup      An array of DOM nodes that share the same name. Use luga.form.utils.getFieldGroup() to obtain it. Required\r\n\t * @property {String} message                      Error message. Can also be set using the \"data-lugavalidator-message\" attribute. Optional\r\n\t * @property {String} errorclass                   CSS class to apply for invalid state. Can also be set using the \"data-lugavalidator-errorclass\" attribute. Optional\r\n\t */\r\n\r\n\t/**\r\n\t * Radio button group validator class\r\n\t *\r\n\t * @constructor\r\n\t * @extend luga.validator.BaseGroupValidator\r\n\t * @param {luga.validator.RadioValidator.options} options\r\n\t *\r\n\t */\r\n\tluga.validator.RadioValidator = function(options){\r\n\t\t/** @type {luga.validator.RadioValidator.options} */\r\n\t\tthis.config = {};\r\n\t\tluga.merge(this.config, options);\r\n\t\tluga.extend(luga.validator.BaseGroupValidator, this, [this.config]);\r\n\t\tthis.type = \"radio\";\r\n\r\n\t\t/**\r\n\t\t * Return true if the field group is required\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tthis.isRequired = function(){\r\n\t\t\tlet requiredFlag = false;\r\n\t\t\tconst fieldGroup = this.inputGroup;\r\n\t\t\t// Since fields from the same group can have conflicting attribute values, the last one win\r\n\t\t\tfor(let i = 0; i < fieldGroup.length; i++){\r\n\t\t\t\tconst field = fieldGroup[i];\r\n\t\t\t\tif(field.disabled === false){\r\n\t\t\t\t\tif(field.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.REQUIRED) !== null){\r\n\t\t\t\t\t\trequiredFlag = field.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.REQUIRED);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn requiredFlag;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns true if the field satisfy the rules associated with it. False otherwise\r\n\t\t * Be careful, this method contains multiple exit points!!!\r\n\t\t * @override\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tthis.isValid = function(){\r\n\t\t\tif(this.isRequired() === \"true\"){\r\n\t\t\t\tconst fieldGroup = this.inputGroup;\r\n\t\t\t\tfor(let i = 0; i < fieldGroup.length; i++){\r\n\t\t\t\t\tconst field = fieldGroup[i];\r\n\t\t\t\t\t// As long as only one is checked, we are fine\r\n\t\t\t\t\tif(field.checked === true){\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t};\r\n\t};\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.validator.CheckboxValidator.options\r\n\t *\r\n\t * @property @property {Array.<HTMLElement>} inputGroup      An array of DOM nodes that share the same name.  Use luga.form.utils.getFieldGroup() to obtain it. Required\r\n\t * @property {Number} minchecked                             Specify a minimum number of boxes that can be checked in a group. Set it to 1 to allow only one choice. Optional\r\n\t * @property {Number} maxchecked                             Specify a maximum number of boxes that can be checked within a group. Optional\r\n\t * @property {String} message                                Error message. Can also be set using the \"data-lugavalidator-message\" attribute. Optional\r\n\t * @property {String} errorclass                             CSS class to apply for invalid state. Can also be set using the \"data-lugavalidator-errorclass\" attribute. Optional\r\n\t */\r\n\r\n\t/**\r\n\t * Checkboxes group validator class\r\n\t *\r\n\t * @constructor\r\n\t * @extend luga.validator.BaseGroupValidator\r\n\t * @param {luga.validator.CheckboxValidator.options} options\r\n\t *\r\n\t */\r\n\tluga.validator.CheckboxValidator = function(options){\r\n\t\t/** @type {luga.validator.CheckboxValidator.options} */\r\n\t\tthis.config = {};\r\n\t\tluga.merge(this.config, options);\r\n\t\tluga.extend(luga.validator.BaseGroupValidator, this, [this.config]);\r\n\t\tthis.type = \"checkbox\";\r\n\t\tthis.minchecked = 0;\r\n\t\tthis.maxchecked = this.config.inputGroup.length;\r\n\r\n\t\t// Since checkboxes from the same group can have conflicting attribute values, the last one win\r\n\t\tfor(let i = 0; i < this.inputGroup.length; i++){\r\n\t\t\tconst field = this.inputGroup[i];\r\n\t\t\tif(field.disabled === false){\r\n\t\t\t\tif(field.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.MIN_CHECKED) !== null){\r\n\t\t\t\t\tthis.minchecked = field.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.MIN_CHECKED);\r\n\t\t\t\t}\r\n\t\t\t\tif(field.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.MAX_CHECKED) !== null){\r\n\t\t\t\t\tthis.maxchecked = field.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.MAX_CHECKED);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns true if the field satisfy the rules associated with it. False otherwise\r\n\t\t * @override\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tthis.isValid = function(){\r\n\t\t\tlet checkCounter = 0;\r\n\t\t\tconst fieldGroup = this.inputGroup;\r\n\t\t\tfor(let i = 0; i < fieldGroup.length; i++){\r\n\t\t\t\t// For each checked box, increase the counter\r\n\t\t\t\tconst field = this.inputGroup[i];\r\n\t\t\t\tif(field.disabled === false){\r\n\t\t\t\t\tif(field.checked === true){\r\n\t\t\t\t\t\tcheckCounter++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn ((checkCounter >= this.minchecked) && (checkCounter <= this.maxchecked));\r\n\t\t};\r\n\r\n\t};\r\n\r\n\t/* Rules */\r\n\r\n\tluga.namespace(\"luga.validator.rules\");\r\n\r\n\t/**\r\n\t * @param {HTMLElement} fieldNode\r\n\t * @param {luga.validator.FormValidator} validator\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.validator.rules.email = function(fieldNode, validator){\r\n\t\tconst fieldValue = fieldNode.value;\r\n\t\tconst containsAt = (fieldValue.indexOf(\"@\") !== -1);\r\n\t\tconst containDot = (fieldValue.indexOf(\".\") !== -1);\r\n\t\tif((containsAt === true) && (containDot === true)){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * @param {HTMLElement} fieldNode\r\n\t * @param {luga.validator.FormValidator} validator\r\n\t * @return {Boolean}\r\n\t * @throw {Exception}\r\n\t */\r\n\tluga.validator.rules.equalto = function(fieldNode, validator){\r\n\t\tconst secondFieldNode = document.getElementById(validator.config.equalto);\r\n\t\tif(secondFieldNode === null){\r\n\t\t\tthrow(luga.string.format(luga.validator.CONST.MESSAGES.MISSING_EQUAL_TO_FIELD, [validator.config.equalto]));\r\n\t\t}\r\n\t\treturn (fieldNode.value === secondFieldNode.value);\r\n\t};\r\n\r\n\t/**\r\n\t * @param {HTMLElement} fieldNode\r\n\t * @param {luga.validator.FormValidator} validator\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.validator.rules.datepattern = function(fieldNode, validator){\r\n\t\tconst datObj = luga.validator.dateStrToObj(fieldNode.value, validator.config.datepattern);\r\n\t\tif(datObj !== null){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * @param {HTMLElement} fieldNode\r\n\t * @param {luga.validator.FormValidator} validator\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.validator.rules.maxdate = function(fieldNode, validator){\r\n\t\tconst pattern = validator.config.datepattern;\r\n\t\tconst valueDate = luga.validator.dateStrToObj(fieldNode.value, pattern);\r\n\t\tconst maxDate = luga.validator.dateStrToObj(validator.config.maxdate, pattern);\r\n\t\tif((valueDate !== null) && (maxDate !== null)){\r\n\t\t\treturn valueDate <= maxDate;\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * @param {HTMLElement} fieldNode\r\n\t * @param {luga.validator.FormValidator} validator\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.validator.rules.mindate = function(fieldNode, validator){\r\n\t\tconst pattern = validator.config.datepattern;\r\n\t\tconst valueDate = luga.validator.dateStrToObj(fieldNode.value, pattern);\r\n\t\tconst minDate = luga.validator.dateStrToObj(validator.config.mindate, pattern);\r\n\t\tif((valueDate !== null) && (minDate !== null)){\r\n\t\t\treturn valueDate >= minDate;\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * @param {HTMLElement} fieldNode\r\n\t * @param {luga.validator.FormValidator} validator\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.validator.rules.maxlength = function(fieldNode, validator){\r\n\t\tif(fieldNode.value.length > validator.config.maxlength){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n\t * @param {HTMLElement} fieldNode\r\n\t * @param {luga.validator.FormValidator} validator\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.validator.rules.minlength = function(fieldNode, validator){\r\n\t\tif(fieldNode.value.length < validator.config.minlength){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n\t * @param {HTMLElement} fieldNode\r\n\t * @param {luga.validator.FormValidator} validator\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.validator.rules.maxnumber = function(fieldNode, validator){\r\n\t\tif(isNumeric(fieldNode.value) === false){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif(parseFloat(fieldNode.value) <= parseFloat(validator.config.maxnumber)){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * @param {HTMLElement} fieldNode\r\n\t * @param {luga.validator.FormValidator} validator\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.validator.rules.minnumber = function(fieldNode, validator){\r\n\t\tif(isNumeric(fieldNode.value) === false){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif(parseFloat(fieldNode.value) >= parseFloat(validator.config.minnumber)){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * @param {HTMLElement} fieldNode\r\n\t * @param {luga.validator.FormValidator} validator\r\n\t * @return {Boolean}\r\n\t * @throw {Exception}\r\n\t */\r\n\tluga.validator.rules.pattern = function(fieldNode, validator){\r\n\t\tconst regExpObj = luga.validator.patterns[validator.config.pattern];\r\n\t\tif(regExpObj !== undefined){\r\n\t\t\treturn regExpObj.test(fieldNode.value);\r\n\t\t}\r\n\t\telse{\r\n\t\t\t// The pattern is missing\r\n\t\t\tthrow(luga.string.format(luga.validator.CONST.MESSAGES.PATTERN_NOT_FOUND, [validator.config.pattern]));\r\n\t\t}\r\n\t};\r\n\r\n\t/* Patterns */\r\n\r\n\tluga.namespace(\"luga.validator.patterns\");\r\n\r\n\tluga.validator.patterns.lettersonly = new RegExp(\"^[a-zA-Z]*$\");\r\n\tluga.validator.patterns.alphanumeric = new RegExp(\"^\\\\w*$\");\r\n\tluga.validator.patterns.integer = new RegExp(\"^-?[1-9][0-9]*$\");\r\n\tluga.validator.patterns.positiveinteger = new RegExp(\"^\\\\d\\\\d*$\");\r\n\tluga.validator.patterns.number = new RegExp(\"^-?(\\\\d\\\\d*\\\\.\\\\d*$)|(^-?\\\\d\\\\d*$)|(^-?\\\\.\\\\d\\\\d*$)\");\r\n\tluga.validator.patterns.filepath_pdf = new RegExp(\"[\\\\w_]*\\\\.([pP][dD][fF])$\");\r\n\tluga.validator.patterns.filepath_jpg = new RegExp(\"[\\\\w_]*\\\\.([jJ][pP][eE]?[gG])$\");\r\n\tluga.validator.patterns.filepath_zip = new RegExp(\"[\\\\w_]*\\\\.([zZ][iI][pP])$\");\r\n\tluga.validator.patterns.filepath = new RegExp(\"[\\\\w_]*\\\\.\\\\w{3}$\");\r\n\tluga.validator.patterns.time = new RegExp(\"([0-1][0-9]|2[0-3]):[0-5][0-9]$\");\r\n\r\n\t/* Date specifications */\r\n\r\n\tluga.namespace(\"luga.validator.dateSpecs\");\r\n\r\n\t/**\r\n\t * Create an object that stores date validation's info\r\n\t *\r\n\t * @param {regexp} rex\r\n\t * @param {Number} year\r\n\t * @param {Number} month\r\n\t * @param {Number} day\r\n\t * @param {String} separator\r\n\t *\r\n\t * @return {Object}\r\n\t */\r\n\tluga.validator.createDateSpecObj = function(rex, year, month, day, separator){\r\n\t\tconst infoObj = {};\r\n\t\tinfoObj.rex = new RegExp(rex);\r\n\t\tinfoObj.y = year;\r\n\t\tinfoObj.m = month;\r\n\t\tinfoObj.d = day;\r\n\t\tinfoObj.s = separator;\r\n\t\treturn infoObj;\r\n\t};\r\n\r\n\t/**\r\n\t * Create a Date object out of a string, based on a given date spec key\r\n\t *\r\n\t * @param {String}   dateStr\r\n\t * @param {String}   dateSpecKey\r\n\t * @return {date|*}\r\n\t */\r\n\tluga.validator.dateStrToObj = function(dateStr, dateSpecKey){\r\n\t\tconst dateSpecObj = luga.validator.dateSpecs[dateSpecKey];\r\n\t\tif(dateSpecObj !== undefined){\r\n\r\n\t\t\t// If it doesn't matches the RegExp, abort\r\n\t\t\tif(!dateSpecObj.rex.test(dateStr)){\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\t// String's value matches the pattern, check if it's a valida date\r\n\t\t\t// Split the date into 3 different bits using the separator\r\n\t\t\tconst dateBits = dateStr.split(dateSpecObj.s);\r\n\t\t\t// First try to create a new date out of the bits\r\n\t\t\tconst testDate = new Date(dateBits[dateSpecObj.y], (dateBits[dateSpecObj.m] - 1), dateBits[dateSpecObj.d]);\r\n\t\t\t// Make sure values match after conversion\r\n\t\t\tconst yearMatches = (testDate.getFullYear() === parseInt(dateBits[dateSpecObj.y], 10));\r\n\t\t\tconst monthMatches = (testDate.getMonth() === parseInt(dateBits[dateSpecObj.m] - 1, 10));\r\n\t\t\tconst dayMatches = (testDate.getDate() === parseInt(dateBits[dateSpecObj.d], 10));\r\n\t\t\tif((yearMatches === true) && (monthMatches === true) && (dayMatches === true)){\r\n\t\t\t\treturn testDate;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn null;\r\n\t};\r\n\r\n\tluga.validator.dateSpecs[\"YYYY-MM-DD\"] = luga.validator.createDateSpecObj(\"^([0-9]{4})-([0-1][0-9])-([0-3][0-9])$\", 0, 1, 2, \"-\");\r\n\tluga.validator.dateSpecs[\"YYYY-M-D\"] = luga.validator.createDateSpecObj(\"^([0-9]{4})-([0-1]?[0-9])-([0-3]?[0-9])$\", 0, 1, 2, \"-\");\r\n\tluga.validator.dateSpecs[\"MM.DD.YYYY\"] = luga.validator.createDateSpecObj(\"^([0-1][0-9]).([0-3][0-9]).([0-9]{4})$\", 2, 0, 1, \".\");\r\n\tluga.validator.dateSpecs[\"M.D.YYYY\"] = luga.validator.createDateSpecObj(\"^([0-1]?[0-9]).([0-3]?[0-9]).([0-9]{4})$\", 2, 0, 1, \".\");\r\n\tluga.validator.dateSpecs[\"MM/DD/YYYY\"] = luga.validator.createDateSpecObj(\"^([0-1][0-9])/([0-3][0-9])/([0-9]{4})$\", 2, 0, 1, \"/\");\r\n\tluga.validator.dateSpecs[\"M/D/YYYY\"] = luga.validator.createDateSpecObj(\"^([0-1]?[0-9])/([0-3]?[0-9])/([0-9]{4})$\", 2, 0, 1, \"/\");\r\n\tluga.validator.dateSpecs[\"MM-DD-YYYY\"] = luga.validator.createDateSpecObj(\"^([0-21][0-9])-([0-3][0-9])-([0-9]{4})$\", 2, 0, 1, \"-\");\r\n\tluga.validator.dateSpecs[\"M-D-YYYY\"] = luga.validator.createDateSpecObj(\"^([0-1]?[0-9])-([0-3]?[0-9])-([0-9]{4})$\", 2, 0, 1, \"-\");\r\n\tluga.validator.dateSpecs[\"DD.MM.YYYY\"] = luga.validator.createDateSpecObj(\"^([0-3][0-9]).([0-1][0-9]).([0-9]{4})$\", 2, 1, 0, \".\");\r\n\tluga.validator.dateSpecs[\"D.M.YYYY\"] = luga.validator.createDateSpecObj(\"^([0-3]?[0-9]).([0-1]?[0-9]).([0-9]{4})$\", 2, 1, 0, \".\");\r\n\tluga.validator.dateSpecs[\"DD/MM/YYYY\"] = luga.validator.createDateSpecObj(\"^([0-3][0-9])/([0-1][0-9])/([0-9]{4})$\", 2, 1, 0, \"/\");\r\n\tluga.validator.dateSpecs[\"D/M/YYYY\"] = luga.validator.createDateSpecObj(\"^([0-3]?[0-9])/([0-1]?[0-9])/([0-9]{4})$\", 2, 1, 0, \"/\");\r\n\tluga.validator.dateSpecs[\"DD-MM-YYYY\"] = luga.validator.createDateSpecObj(\"^([0-3][0-9])-([0-1][0-9])-([0-9]{4})$\", 2, 1, 0, \"-\");\r\n\tluga.validator.dateSpecs[\"D-M-YYYY\"] = luga.validator.createDateSpecObj(\"^([0-3]?[0-9])-([0-1]?[0-9])-([0-9]{4})$\", 2, 1, 0, \"-\");\r\n\r\n\t/**\r\n\t * Attach form validators to any suitable form inside the given DOM node\r\n\t * @param {HTMLElement} [rootNode]  Optional, default to document.body\r\n\t */\r\n\tluga.validator.initForms = function(rootNode){\r\n\t\tif(rootNode === undefined){\r\n\t\t\trootNode = document.body;\r\n\t\t}\r\n\t\tconst nodes = rootNode.querySelectorAll(luga.validator.CONST.FORM_SELECTOR);\r\n\t\tfor(let i = 0; i < nodes.length; i++){\r\n\t\t\tconst element = nodes[i];\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(element.getAttribute(luga.validator.CONST.CUSTOM_ATTRIBUTES.VALIDATE) === \"true\"){\r\n\t\t\t\telement.addEventListener(\"submit\", function(event){\r\n\t\t\t\t\tconst formValidator = new luga.validator.FormValidator({\r\n\t\t\t\t\t\tformNode: element\r\n\t\t\t\t\t});\r\n\t\t\t\t\tformValidator.validate(event);\r\n\t\t\t\t}, false);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tluga.namespace(\"luga.validator.utils\");\r\n\r\n\tluga.validator.utils.CONST = {\r\n\t\tCSS_CLASSES: {\r\n\t\t\tMESSAGE: \"luga-message\",\r\n\t\t\tERROR_MESSAGE: \"luga-error-message\"\r\n\t\t},\r\n\t\tMSG_BOX_ID: \"lugaMessageBox\"\r\n\t};\r\n\r\n\t/**\r\n\t * Private helper function\r\n\t * Generate node's id\r\n\t * @param {HTMLElement} node\r\n\t * @return {String}\r\n\t */\r\n\tconst generateBoxId = function(node){\r\n\t\tlet boxId = luga.validator.utils.CONST.MSG_BOX_ID;\r\n\t\t/* istanbul ignore else */\r\n\t\tif(node !== undefined){\r\n\t\t\tif(node.getAttribute(\"id\") === null){\r\n\t\t\t\tboxId += node.getAttribute(\"id\");\r\n\t\t\t}\r\n\t\t\telse if(node.getAttribute(\"name\") !== null){\r\n\t\t\t\tboxId += node.getAttribute(\"name\");\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn boxId;\r\n\t};\r\n\r\n\t/**\r\n\t * Remove a message box (if any) associated with a given node\r\n\t * @param {HTMLElement}  node   Target node\r\n\t */\r\n\tluga.validator.utils.removeDisplayBox = function(node){\r\n\t\tconst boxId = generateBoxId(node);\r\n\t\tconst oldBox = document.getElementById(boxId);\r\n\t\t// If an error display is already there, get rid of it\r\n\t\t/* istanbul ignore else */\r\n\t\tif(oldBox !== null){\r\n\t\t\toldBox.outerHTML = \"\";\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Display a message box above a given node\r\n\t * @param {HTMLElement}  node   Target node\r\n\t * @param {String}       html   HTML/Text code to inject\r\n\t * @return {HTMLElement}\r\n\t */\r\n\tluga.validator.utils.displayMessage = function(node, html){\r\n\t\treturn luga.validator.utils.displayBox(node, html, luga.validator.utils.CONST.CSS_CLASSES.MESSAGE);\r\n\t};\r\n\r\n\t/**\r\n\t * Display an error box above a given node\r\n\t * @param {HTMLElement}  node   Target node\r\n\t * @param {String}       html   HTML/Text code to inject\r\n\t * @return {HTMLElement}\r\n\t */\r\n\tluga.validator.utils.displayErrorMessage = function(node, html){\r\n\t\treturn luga.validator.utils.displayBox(node, html, luga.validator.utils.CONST.CSS_CLASSES.ERROR_MESSAGE);\r\n\t};\r\n\r\n\t/**\r\n\t * Display a box with a message associated with a given node\r\n\t * Overwrite this method if you want to change the way luga.validator.utils.displayMessage and luga.validator.utils.displayErrorMessage behaves\r\n\t * @param {HTMLElement}  node                  Target node\r\n\t * @param {String}  html                       HTML/Text code to inject\r\n\t * @param {String}  [cssClass=\"luga_message\"]  CSS class attached to the box. Default to \"luga_message\"\r\n\t * @return {HTMLElement}\r\n\t */\r\n\tluga.validator.utils.displayBox = function(node, html, cssClass){\r\n\t\tif(node === undefined){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(cssClass === undefined){\r\n\t\t\tcssClass = luga.validator.utils.CONST.CSS_CLASSES.MESSAGE;\r\n\t\t}\r\n\t\tconst boxId = generateBoxId(node);\r\n\t\tconst box = document.createElement(\"div\");\r\n\t\tbox.setAttribute(\"id\", boxId);\r\n\t\tbox.classList.add(cssClass);\r\n\t\tbox.innerHTML = html;\r\n\r\n\t\tconst oldBox = document.getElementById(boxId);\r\n\t\t// If a box display is already there, replace it, if not, we create one from scratch\r\n\t\tif(oldBox !== null){\r\n\t\t\t// A bit brutal, but does the job\r\n\t\t\toldBox.outerHTML = box.outerHTML\r\n\t\t}\r\n\t\telse{\r\n\t\t\tnode.insertBefore(box, null);\r\n\t\t}\r\n\t\treturn box;\r\n\t};\r\n\r\n\t/* API */\r\n\r\n\tluga.namespace(\"luga.validator.api\");\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.validator.api.validateForm.options\r\n\t *\r\n\t * @property {HTMLElement} formNode     DOM node. Required\r\n\t * @property {Function}        error        Name of the function to be invoked to handle/display validation messages.\r\n\t *                                      Default to luga.validator.errorAlert\r\n\t */\r\n\r\n\t/**\r\n\t * Programmatically validate a form\r\n\t * @param {luga.validator.api.validateForm.options} options\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.validator.api.validateForm = function(options){\r\n\t\tconst formValidator = new luga.validator.FormValidator(options);\r\n\t\tformValidator.validate();\r\n\t\treturn formValidator.isValid();\r\n\t};\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.validator.api.validateField.options\r\n\t *\r\n\t * @property {HTMLElement} fieldNode    DOM node. Required\r\n\t * @property {Function}      error      Function to be invoked to handle/display validation messages.\r\n\t *                                      Default to luga.validator.errorAlert\r\n\t */\r\n\r\n\t/**\r\n\t * Programmatically validate a field\r\n\t * @param {luga.validator.api.validateField.options} options\r\n\t * @return {Boolean}\r\n\t * @throw {Exception}\r\n\t */\r\n\tluga.validator.api.validateField = function(options){\r\n\t\tif(luga.form.utils.isInputField(options.fieldNode) === false){\r\n\t\t\tthrow(luga.validator.CONST.MESSAGES.FIELD_CANT_BE_VALIDATED);\r\n\t\t}\r\n\t\t/* istanbul ignore else */\r\n\t\tif(options.error === undefined){\r\n\t\t\toptions.error = luga.validator.CONST.HANDLERS.FORM_ERROR;\r\n\t\t}\r\n\t\tconst dirtyValidators = [];\r\n\t\tconst fieldValidator = luga.validator.fieldValidatorFactory.getInstance(options);\r\n\t\tfieldValidator.validate(null);\r\n\t\tif(fieldValidator.isValid() !== true){\r\n\t\t\tconst callBack = luga.lookupFunction(options.error);\r\n\t\t\tdirtyValidators.push(fieldValidator);\r\n\t\t\tcallBack(options.fieldNode, dirtyValidators);\r\n\t\t}\r\n\t\treturn fieldValidator.isValid();\r\n\t};\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.validator.api.validateField.options\r\n\t *\r\n\t * @property {Nodelist} fields     Nodelist. Required\r\n\t * @property {Function}  error     Function to be invoked to handle/display validation messages.\r\n\t *                                 Default to luga.validator.errorAlert\r\n\t */\r\n\r\n\t/**\r\n\t * Programmatically validate a collection of fields\r\n\t * @param {luga.validator.api.validateFields.options} options\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.validator.api.validateFields = function(options){\r\n\t\t/* istanbul ignore else */\r\n\t\tif(!options.error){\r\n\t\t\toptions.error = luga.validator.CONST.HANDLERS.FORM_ERROR;\r\n\t\t}\r\n\t\tconst validators = [];\r\n\t\tconst executedValidators = {};\r\n\t\tconst dirtyValidators = [];\r\n\r\n\t\tfor(let i = 0; i < options.fields.length; i++){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(luga.form.utils.isInputField(options.fields[i]) === true){\r\n\t\t\t\tvalidators.push(luga.validator.fieldValidatorFactory.getInstance({\r\n\t\t\t\t\tfieldNode: options.fields[i]\r\n\t\t\t\t}));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor(let j = 0; j < validators.length; j++){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(validators[j] && validators[j].validate){\r\n\t\t\t\tif(executedValidators[validators[j].name] !== undefined){\r\n\t\t\t\t\t// Already validated checkbox or radio, skip it\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif(validators[j].validate() === true){\r\n\t\t\t\t\tdirtyValidators.push(validators[j]);\r\n\t\t\t\t}\r\n\t\t\t\texecutedValidators[validators[j].name] = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(dirtyValidators.length > 0){\r\n\t\t\tconst callBack = luga.lookupFunction(options.error);\r\n\t\t\tcallBack.apply(null, [options.formNode, dirtyValidators]);\r\n\t\t}\r\n\t\treturn dirtyValidators.length === 0;\r\n\t};\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.validator.api.validateFields.options\r\n\t *\r\n\t * @property {HTMLElement} rootNode    DOM node. Required\r\n\t * @property {Function} error          Function to be invoked to handle/display validation messages.\r\n\t *                                     Default to luga.validator.errorAlert\r\n\t */\r\n\r\n\t/**\r\n\t * Programmatically validate all fields contained inside a given node\r\n\t * @param {luga.validator.api.validateFields.options} options\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.validator.api.validateChildFields = function(options){\r\n\t\tconst fields = luga.form.utils.getChildFields(options.rootNode);\r\n\t\treturn luga.validator.api.validateFields({\r\n\t\t\tfields: fields,\r\n\t\t\terror: options.error\r\n\t\t});\r\n\t};\r\n\r\n\tluga.dom.ready(function(){\r\n\t\tluga.validator.initForms();\r\n\t});\r\n\r\n}());"],"sourceRoot":"."}